#! /bin/bash

##  Copyright (c)  Alex Genovese   https://github.com/TuxVinyards

# 	licence:  GPL3   https://www.gnu.org/licenses 


##  A modified version of the 'quickemu' frontend for 'qemu'

#   that provides a text menu interface & more modifiable qemu settings

#   https://github.com/quickemu-project/quickemu   https://gitlab.com/qemu-project/qemu

#   Users should install 'quickemu' and may set up Virtual Machines as normal.


#   Q-Mod may be installed alongside quickemu in /usr/bin  & run by typing 'q-mod' or 'quickemu-mod' 

#   Or renamed as quickemu & used as a replacement for the standard one. 

#   The script may be placed elsewhere, including your desktop or the main VM folder where the vm.conf files are located. 

#   Click on this script to run it, or open an in-folder terminal and use './quickemu-mod'  (make sure it has execute permissions)



VERSION="4.4.mod"


##  Some sections of 'quickemu' will have been modified for readability, others may be as-is ....

#  For as-is code taken directly from the quickemu repository, the MIT licence may apply.

#  See accompanying LICENCE text file.

#  If adding code, please refer to  http://mywiki.wooledge.org/BashGuide/Practices#Readability  



# API

#   Use  --mod.menu  "path/folder"  "file.conf"  for  direct calls that bypass of the array selector. 

#   Or   --mod.conf   "file.conf"    for .conf files in the default VM folder



## SETTINGS   

#  For details, see notes at start of settings file

#  Use full quoted path & name if in different folder to this script or different to a default


CurrentFolder="$(pwd)"


if [[ -e "$CurrentFolder/qmod_settings" ]] && [[ "$CurrentFolder" != '/usr'* ]]; then  

  Q_Mod_SettingsFile="$CurrentFolder/qmod_settings"

elif [[ -e "$CurrentFolder/.qmod_settings" ]] && [[ "$CurrentFolder" != '/usr'* ]]; then  

  Q_Mod_SettingsFile="$CurrentFolder/.qmod_settings"

elif [[ -e "/$HOME/.qmod_settings" ]] ; then  

  Q_Mod_SettingsFile="/$HOME/.qmod_settings"

elif [[ -e "/$HOME/qmod_settings" ]] ; then  

  Q_Mod_SettingsFile="/$HOME/qmod_settings"

else  

  Q_Mod_SettingsFile=  
  
fi


# Declare global associative VM ARRAY 

declare -gA VM_Array=()


# Load Settings & Array Presets  (flag QMOD)

if [[ -e "$Q_Mod_SettingsFile" ]]; then

  # shellcheck disable=SC1090

 . "$Q_Mod_SettingsFile"  QMOD

else

  printf "\n\n  ERROR  'qmod_settings' file not found \n\n  Re-check Installation &/or Installation instructions \n\n"
  
fi


# Make sure that 'Default_VM_Folder' has a value

[[ ! $Default_VM_Folder ]] && Default_VM_Folder="$CurrentFolder"


## Make sure shell is set during session to decimal separator of dot 

#  LC_ALL=C changes too much, just set the numeric.

#  See locale setting discussion:  https://unix.stackexchange.com/a/149129 

#  Also  https://unix.stackexchange.com/questions/62316/why-is-there-no-euro-english-locale?rq=1

#  &   http://www.unicode.org/L2/L2001/01102-POSIX15897.htm   


export "LC_NUMERIC=C"

export "LC_COLLATE=C"


##  MOD  Standard Quickemu checks for '< 4' which at 2022/3 now needs a bump. 

#   Some ver 5 script is present in the standard release too ...

#   More Version 5 style scripting should be used:

#   See http://mywiki.wooledge.org/BashGuide/Practices#Choose_Your_Shell

if ((BASH_VERSINFO[0] < 5)); then
  echo "Sorry, you need Bash 5.0 or newer to run this script."
  exit 1
fi


LAUNCHER="$(basename "$0")"
DISK_MIN_SIZE=$((197632 * 8))


QEMU=$(command -v qemu-system-x86_64)
QEMU_IMG=$(command -v qemu-img)

if [ ! -e "${QEMU}" ] || [ ! -e "${QEMU_IMG}" ]; then
  echo "ERROR! QEMU not found. Please make install qemu-system-x86_64 and qemu-img"
  exit 1
fi


show_qe_api_usage () {

  ## quickemu-mod itself doesn't have a direct API, as does std quickemu  

  #  q-mod routes the standard API into quickemu as a built in function

  #  BUT the modding has been tweaked so that the standard methods can still be used (by quickgui for example ??)

  #  Use this table for reference. Some items have been modded out.
  
  #  The parameter '--help' has been added for original quickemu use as command without parameters now routes to the menu system


  printColor    "\n\n  Command line API Usage:  "
  
  printf        "%s --vm  vm-name.conf  [--path \"/path/to/vm/folder\"] " "$LAUNCHER"    

  printf    "\n\n  Replace '--vm'  with '--vm-menu'  to use menu mode. Optional parameter '--path' may be used."

  printf    "\n\n  The starting terminal should be located in the VM folder or a path should be supplied. "


  printf  "\n\n\n  QuickEmu-Mod may be started in-situ in a folder terminal:  ./quickmod-mod   or by mouse click"

  printf    "\n\n  It can be placed in 'usr/bin' alongside original 'quickemu' or renamed there to 'quickemu' to work as a "

  printf    "\n\n  drop in replacement. QMOD HAS SOME NEW ADDED COMMANDS & WILL ACCEPT MOST OF THE ORIGINAL ONES."


  printf  "\n\n\n  Non-Menu Mode additional optional parameters: \n\n"

  read -rp "  [enter] to continue > "

  #  Erase text and adjust cursor:   "\e[1A\r"  "\e[2K\r"  etc    See https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797

  printf "\e[1A\r"


  # echo "  --shortcut                      : Create a desktop shortcut"     #  Not needed with q-mod

  # echo "  --ignore-msrs-always            : Always ignore KVM unhandled machine-specific registers"   #  Too permanent & Code needed improvements.

  #                                         : MOD Re-Written as a reversible function 'toggle_msr_defaults' 

  echo "  --version                         : Show versioning"  
  echo "  --help | -h                       : Show help"  
  echo "  --path                            : If the starting terminal is not located in the VM folder, a path should be supplied"  
  echo "  --toggle_msr_defaults             : Configure default KVM behaviour for unhandled machine-specific registers"    
  echo "  --braille                         : Enable braille support. Requires SDL."
  echo "  --display                         : Select display backend. 'sdl' (default), 'gtk', 'none', 'spice' or 'spice-app'"
  echo "  --fullscreen                      : Starts VM in full screen mode (Ctl+Alt+f to exit)"
  echo "  --screen <screen>                 : Use specified screen to determine the window size."
  echo "  --snapshot apply <tag>            : Apply/restore a snapshot."
  echo "  --snapshot create <tag>           : Create a snapshot."
  echo "  --snapshot delete <tag>           : Delete a snapshot."
  echo "  --snapshot info                   : Show disk/snapshot info."
  echo "  --status-quo                      : Do not commit any changes to disk/snapshot."
  echo "  --viewer <viewer>                 : Choose an alternative viewer. @Options: 'spicy' (default), 'remote-viewer', 'none'"
  echo "  --ssh-port <port>                 : Set ssh-port manually"
  echo "  --spice-port <port>               : Set spice-port manually"
  echo "  --public-dir <path>               : expose share directory. @Options: '' (default: xdg-user-dir PUBLICSHARE), '<directory>', 'none'"
  echo "  --monitor <type>                  : Set monitor connection type. @Options: 'socket' (default), 'telnet', 'none'"
  echo "  --monitor-telnet-host <ip/host>   : Set telnet host for monitor. (default: 'localhost')"
  echo "  --monitor-telnet-port <port>      : Set telnet port for monitor. (default: '4440')"
  echo "  --monitor-cmd <cmd>               : Send command to monitor if available. (Example: system_powerdown)"
  echo "  --serial <type>                   : Set serial connection type. @Options: 'socket' (default), 'telnet', 'none'"
  echo "  --serial-telnet-host <ip/host>    : Set telnet host for serial. (default: 'localhost')"
  echo "  --serial-telnet-port <port>       : Set telnet port for serial. (default: '6660')"
  echo "  --keyboard <type>                 : Set keyboard. @Options: 'usb' (default), 'ps2', 'virtio'"
  echo "  --keyboard_layout <layout>        : Set keyboard layout."
  echo "  --mouse <type>                    : Set mouse. @Options: 'tablet' (default), 'ps2', 'usb', 'virtio'"
  echo "  --usb-controller <type>           : Set usb-controller. @Options: 'ehci' (default), 'xhci', 'none'"
  echo "  --show_args                       : Show all the compiled qemu & swmtp arguments as a human readable list, before starting VM"
  echo
  echo "    extra_args                      : Extra args may be placed in the settings file (MOD) "

  
  # Enabled for use by 'quickgui'           : This is not really necessary for Q Mod as its interface is more file manager based.   REVIEW 
  
  echo "  --delete-disk                     : Delete the disk image and EFI variables"     
  echo "  --delete-vm                       : Delete the entire VM and it's configuration"


  # printf  "\n\n\n  QuickEmu-Mod may be started in-situ in a folder terminal:  ./quickmod-mod   or by mouse click"

  # printf    "\n\n  It can be placed in 'usr/bin' alongside original 'quickemu' or renamed there to 'quickemu' to work as a "

  # printf    "\n\n  drop in replacement. QMOD will accept most of the original quickemu commands, as detailed."
  
  [[ $CLI ]] && exit 0

  printf    "\n\n\n"

}


##  Load these two delete functions for quickgui (if substituting quickemu-mod for the standard release... )

function delete_disk() {
  if [ -e "${disk_img}" ]; then
    rm "${disk_img}"
    # Remove any EFI vars, but not for macOS
    rm "${VMDIR}"/OVMF_VARS*.fd >/dev/null 2>&1
    rm "${VMPATH}/${VMDIR}"/OVMF_VARS*.fd >/dev/null 2>&1
    rm "${VMDIR}/${VMNAME}-vars.fd" >/dev/null 2>&1
    rm "${VMPATH}/${VMDIR}/${VMNAME}-vars.fd" > /dev/null 2>&1
    echo "SUCCESS! Deleted ${disk_img}"
    delete_shortcut
  else
    echo "NOTE! ${disk_img} not found. Doing nothing."
  fi
}

function delete_vm() {
  if [ -d "${VMDIR}" ]; then
    rm -rf "${VMDIR}"
    rm "${VM}"
    echo "SUCCESS! Deleted ${VM} and ${VMDIR}"
    delete_shortcut
  else
    echo "NOTE! ${VMDIR} not found. Doing nothing."
  fi
}


## LOAD other quickemu functions into the quickemu-mod envelope  

#  Also loads/converts the two main code sections of quickemu as functions:  'quickemu' & 'quickemu-actions'

function snapshot_apply() {
  local TAG="${1}"
  if [ -z "${TAG}" ]; then
    echo "ERROR! No snapshot tag provided."
    exit
  fi

  if [ -e "${disk_img}" ]; then
    if ${QEMU_IMG} snapshot -q -a "${TAG}" "${disk_img}"; then
      echo "SUCCESS! Applied snapshot ${TAG} to ${disk_img}"
    else
      echo "ERROR! Failed to apply snapshot ${TAG} to ${disk_img}"
    fi
  else
    echo "NOTE! ${disk_img} not found. Doing nothing."
  fi
}

function snapshot_create() {
  local TAG="${1}"
  if [ -z "${TAG}" ]; then
    echo "ERROR! No snapshot tag provided."
    exit
  fi

  if [ -e "${disk_img}" ]; then
    if ${QEMU_IMG} snapshot -q -c "${TAG}" "${disk_img}"; then
      echo "SUCCESS! Created snapshot ${TAG} of ${disk_img}"
    else
      echo "ERROR! Failed to create snapshot ${TAG} of ${disk_img}"
    fi
  else
    echo "NOTE! ${disk_img} not found. Doing nothing."
  fi
}

function snapshot_delete() {
  local TAG="${1}"
  if [ -z "${TAG}" ]; then
    echo "ERROR! No snapshot tag provided."
    exit
  fi

  if [ -e "${disk_img}" ]; then
    if ${QEMU_IMG} snapshot -q -d "${TAG}" "${disk_img}"; then
      echo "SUCCESS! Deleted snapshot ${TAG} of ${disk_img}"
    else
      echo "ERROR! Failed to delete snapshot ${TAG} of ${disk_img}"
    fi
  else
    echo "NOTE! ${disk_img} not found. Doing nothing."
  fi
}

function snapshot_info() {
  if [ -e "${disk_img}" ]; then
    ${QEMU_IMG} info "${disk_img}"
  fi
}

function get_port() {
    local PORT_START=$1
    local PORT_RANGE=$((PORT_START+$2))
    local PORT
    for ((PORT = PORT_START; PORT <= PORT_RANGE; PORT++)); do
        # Make sure port scans do not block too long.
        timeout 0.1s bash -c "echo >/dev/tcp/127.0.0.1/${PORT}" >/dev/null 2>&1
        if [ ${?} -eq 1 ]; then
            echo "${PORT}"
            break
        fi
    done
}

function enable_usb_passthrough() {
  local DEVICE=""
  local USB_BUS=""
  local USB_DEV=""
  local USB_NAME=""
  local VENDOR_ID=""
  local PRODUCT_ID=""
  local USB_NOT_READY=0

  # Have any USB devices been requested for pass-through?
  if (( ${#usb_devices[@]} )); then
    echo " - USB:      Host pass-through requested:"
    for DEVICE in "${usb_devices[@]}"; do
      VENDOR_ID=$(echo "${DEVICE}" | cut -d':' -f1)
      PRODUCT_ID=$(echo "${DEVICE}" | cut -d':' -f2)
      USB_BUS=$(lsusb -d "${VENDOR_ID}:${PRODUCT_ID}" | cut -d' ' -f2)
      USB_DEV=$(lsusb -d "${VENDOR_ID}:${PRODUCT_ID}" | cut -d' ' -f4 | cut -d':' -f1)
      USB_NAME=$(lsusb -d "${VENDOR_ID}:${PRODUCT_ID}" | cut -d' ' -f7-)
      if [ -z "${USB_NAME}" ]; then
        echo "             ! USB device ${VENDOR_ID}:${PRODUCT_ID} not found. Check your configuration"
        continue
      elif [ -w "/dev/bus/usb/${USB_BUS}/${USB_DEV}" ]; then
        echo "             o ${USB_NAME} on bus ${USB_BUS} device ${USB_DEV} is accessible."
      else
        echo "             x ${USB_NAME} on bus ${USB_BUS} device ${USB_DEV} needs permission changes:"
        echo "               sudo chown -v root:${USER} /dev/bus/usb/${USB_BUS}/${USB_DEV}"
        USB_NOT_READY=1
      fi
      USB_PASSTHROUGH="${USB_PASSTHROUGH} -device usb-host,bus=hostpass.0,vendorid=0x${VENDOR_ID},productid=0x${PRODUCT_ID}"
    done

    if [ "${USB_NOT_READY}" -eq 1 ]; then
      echo "               ERROR! USB permission changes are required 👆"
      exit 1
    fi
  fi
}


function check_cpu_flag() {
  local HOST_CPU_FLAG="${1}"
  if lscpu | grep -o "^Flags\b.*: .*\b${HOST_CPU_FLAG}\b" > /dev/null; then
    return 0
  else
    return 1
  fi
}

function efi_vars() {
  local VARS_IN=""
  local VARS_OUT=""
  VARS_IN="${1}"
  VARS_OUT="${2}"

  if [ ! -e "${VARS_OUT}" ]; then
    if [ -e "${VARS_IN}" ]; then
      cp "${VARS_IN}" "${VARS_OUT}"
    else
      echo "ERROR! ${VARS_IN} was not found. Please install edk2."
      exit 1
    fi
  fi
}

function vm_boot() {

  local AUDIO_DEV=""
  local BALLOON="-device virtio-balloon"  
  local BOOT_STATUS=""
  local CPU=""
  local DISK_USED=""
  local DISPLAY_DEVICE=""
  local DISPLAY_RENDER=""
  local EFI_CODE="${EFI_CODE}"
  local EFI_VARS=""
  local GUEST_CPU_CORES=""
  local GUEST_CPU_LOGICAL_CORES=""
  local GUEST_CPU_THREADS=""
  local HOST_CPU_CORES=""
  local HOST_CPU_SMT=""
  local HOST_CPU_SOCKETS=""
  local HOST_CPU_VENDOR=""
  local GUEST_TWEAKS=""
  local KERNEL_NAME="Unknown"
  local KERNEL_NODE=""
  local KERNEL_VER="?"
  local LSB_DESCRIPTION="Unknown OS"
  local MACHINE_TYPE="${MACHINE_TYPE:-q35}"
  local MAC_BOOTLOADER=""
  local MAC_MISSING=""
  local MAC_DISK_DEV="${MAC_DISK_DEV:-ide-hd,bus=ahci.2}"
  local NET_DEVICE="${NET_DEVICE:-virtio-net}"
  local OSK=""
  local SMM="${SMM:-off}"
  local USB_HOST_PASSTHROUGH_CONTROLLER="qemu-xhci"
  local VGA=""
  local VIDEO=""

  KERNEL_NAME=$(uname --kernel-name)
  KERNEL_NODE="($(uname --nodename))"
  KERNEL_VER=$(uname --kernel-release | cut -d'.' -f1-2)

  if command -v lsb_release &>/dev/null; then
    LSB_DESCRIPTION=$(lsb_release --description --short)
  elif [ -e /etc/os-release ]; then
    LSB_DESCRIPTION=$(grep PRETTY_NAME /etc/os-release | cut -d'"' -f2)
  fi

  echo
  echo " Quickemu ${VERSION} using ${QEMU} v${QEMU_VER_LONG}"
  echo
  echo " Compiling the following instructions for qemu:"
  echo
  echo " - Host:     ${LSB_DESCRIPTION} running ${KERNEL_NAME} ${KERNEL_VER} ${KERNEL_NODE}"

  HOST_CPU_CORES=$(nproc --all)
  HOST_CPU_MODEL=$(lscpu | grep '^Model name:' | cut -d':' -f2 | sed 's/  //g')
  HOST_CPU_SOCKETS=$(lscpu | grep -E 'Socket' | cut -d':' -f2 | sed 's/ //g')
  HOST_CPU_VENDOR=$(lscpu | grep -E 'Vendor' | cut -d':' -f2 | sed 's/ //g')

  # A CPU with Intel VT-x / AMD SVM support is required
  if [ "${HOST_CPU_VENDOR}" == "GenuineIntel" ]; then
    if ! check_cpu_flag vmx; then
      echo "ERROR! Intel VT-x support is required."
      exit 1
    fi
  elif [ "${HOST_CPU_VENDOR}" == "AuthenticAMD" ]; then
    if ! check_cpu_flag svm; then
      echo "ERROR! AMD SVM support is required."
      exit 1
    fi
  fi

  if [ -z "${cpu_cores}" ]; then
      if [ "${HOST_CPU_CORES}" -ge 32 ]; then
        GUEST_CPU_CORES="16"
      elif [ "${HOST_CPU_CORES}" -ge 16 ]; then
        GUEST_CPU_CORES="8"
      elif [ "${HOST_CPU_CORES}" -ge 8 ]; then
        GUEST_CPU_CORES="4"
      elif [ "${HOST_CPU_CORES}" -ge 4 ]; then
        GUEST_CPU_CORES="2"
      else
        GUEST_CPU_CORES="1"
      fi
  else
      GUEST_CPU_CORES="${cpu_cores}"
  fi

  # Account for Hyperthreading/SMT.
  if [ -e /sys/devices/system/cpu/smt/control ] && [ "${GUEST_CPU_CORES}" -ge 2 ]; then
    HOST_CPU_SMT=$(cat /sys/devices/system/cpu/smt/control)
    case ${HOST_CPU_SMT} in
      on)
        GUEST_CPU_THREADS=2
        GUEST_CPU_LOGICAL_CORES=$(( GUEST_CPU_CORES / GUEST_CPU_THREADS ))
        ;;
      *)
        GUEST_CPU_THREADS=1
        GUEST_CPU_LOGICAL_CORES=${GUEST_CPU_CORES}
        ;;
    esac
  else
    GUEST_CPU_THREADS=1
    GUEST_CPU_LOGICAL_CORES=${GUEST_CPU_CORES}
  fi

  local SMP="-smp cores=${GUEST_CPU_LOGICAL_CORES},threads=${GUEST_CPU_THREADS},sockets=${HOST_CPU_SOCKETS}"
  echo " - CPU:      ${HOST_CPU_MODEL}"
  echo -n " - CPU VM:   ${HOST_CPU_SOCKETS} Socket(s), ${GUEST_CPU_LOGICAL_CORES} Core(s), ${GUEST_CPU_THREADS} Thread(s)"

  local RAM_VM="2G"
  if [ -z "${ram}" ]; then
      local RAM_HOST=""
      RAM_HOST=$(free --mega -h | grep Mem | cut -d':' -f2 | cut -d'G' -f1 | sed 's/ //g')
      #Round up - https://github.com/wimpysworld/quickemu/issues/11
      RAM_HOST=$(printf '%.*f\n' 0 "${RAM_HOST}")
      if [ "${RAM_HOST}" -ge 128 ]; then
        RAM_VM="32G"
      elif [ "${RAM_HOST}" -ge 64 ]; then
        RAM_VM="16G"
      elif [ "${RAM_HOST}" -ge 16 ]; then
        RAM_VM="8G"
      elif [ "${RAM_HOST}" -ge 8 ]; then
        RAM_VM="4G"
      fi
  else
      RAM_VM="${ram}"
  fi
  echo ", ${RAM_VM} RAM"

  if [ "${guest_os}" == "macos" ] || [ "${guest_os}" == "windows" ]; then
    if [ "${RAM_VM//G/}" -lt 4 ]; then
        echo "ERROR! You have insufficient RAM to run ${guest_os} in a VM"
        exit 1
    fi
  fi

  # Force to lowercase.
  boot=${boot,,}
  guest_os=${guest_os,,}


  ## EFI:

  if [ "${guest_os}" == "macos" ]; then

    # Always Boot macOS using EFI

    boot="efi"
    if [ -e "${VMDIR}/OVMF_CODE.fd" ] && [ -e "${VMDIR}/OVMF_VARS-1024x768.fd" ]; then
      EFI_CODE="${VMDIR}/OVMF_CODE.fd"
      EFI_VARS="${VMDIR}/OVMF_VARS-1024x768.fd"
    else
      MAC_MISSING="Firmware"
    fi

    if [ -e "${VMDIR}/OpenCore.qcow2" ]; then
      MAC_BOOTLOADER="${VMDIR}/OpenCore.qcow2"
    elif [ -e "${VMDIR}/ESP.qcow2" ]; then
      # Backwards compatibility for Clover
      MAC_BOOTLOADER="${VMDIR}/ESP.qcow2"
    else
      MAC_MISSING="Bootloader"
    fi

    if [ -n "${MAC_MISSING}" ]; then
      echo "ERROR! macOS ${MAC_MISSING} was not found."
      echo "       Use 'quickget' to download the required files."
      exit 1
    fi
    BOOT_STATUS="EFI (macOS), OVMF ($(basename "${EFI_CODE}")), SecureBoot (${secureboot})."


  elif [[ "${boot}" == *"efi"* ]]; then

    EFI_VARS="${VMDIR}/OVMF_VARS.fd"

    # Preserve backward compatibility
    if [ -e "${VMDIR}/${VMNAME}-vars.fd" ]; then
      mv "${VMDIR}/${VMNAME}-vars.fd" "${EFI_VARS}"
    elif [ -e "${VMDIR}/OVMF_VARS_4M.fd" ]; then
      mv "${VMDIR}/OVMF_VARS_4M.fd" "${EFI_VARS}"
    fi

    # OVMF_CODE_4M.fd is for booting guests in non-Secure Boot mode.
    # While this image technically supports Secure Boot, it does so
    # without requiring SMM support from QEMU

    # OVMF_CODE.secboot.fd is like OVMF_CODE_4M.fd, but will abort if QEMU
    # does not support SMM.

    # https://bugzilla.redhat.com/show_bug.cgi?id=1929357#c5

    # shellcheck disable=SC2054,SC2206

    if [ -n "${EFI_CODE}" ] || [ ! -e "${EFI_CODE}" ]; then
    
      case ${secureboot} in
        on)
          ovmfs=("/usr/share/OVMF/OVMF_CODE_4M.secboot.fd","/usr/share/OVMF/OVMF_VARS_4M.fd" \
            "/usr/share/edk2/ovmf/OVMF_CODE.secboot.fd","/usr/share/edk2/ovmf/OVMF_VARS.fd" \
            "/usr/share/OVMF/x64/OVMF_CODE.secboot.fd","/usr/share/OVMF/x64/OVMF_VARS.fd" \
            "/usr/share/edk2-ovmf/OVMF_CODE.secboot.fd","/usr/share/edk2-ovmf/OVMF_VARS.fd" \
            "/usr/share/qemu/ovmf-x86_64-smm-ms-code.bin","/usr/share/qemu/ovmf-x86_64-smm-ms-vars.bin" \
            "/usr/share/qemu/edk2-x86_64-secure-code.fd","/usr/share/qemu/edk2-x86_64-code.fd" \
            "/usr/share/edk2-ovmf/x64/OVMF_CODE.secboot.fd","/usr/share/edk2-ovmf/x64/OVMF_VARS.fd"
          )
          ;;
        *)
          ovmfs=("/usr/share/OVMF/OVMF_CODE_4M.fd","/usr/share/OVMF/OVMF_VARS_4M.fd" \
            "/usr/share/edk2/ovmf/OVMF_CODE.fd","/usr/share/edk2/ovmf/OVMF_VARS.fd" \
            "/usr/share/OVMF/OVMF_CODE.fd","/usr/share/OVMF/OVMF_VARS.fd" \
            "/usr/share/OVMF/x64/OVMF_CODE.fd","/usr/share/OVMF/x64/OVMF_VARS.fd" \
            "/usr/share/edk2-ovmf/OVMF_CODE.fd","/usr/share/edk2-ovmf/OVMF_VARS.fd" \
            "/usr/share/qemu/ovmf-x86_64-4m-code.bin","/usr/share/qemu/ovmf-x86_64-4m-vars.bin" \
            "/usr/share/qemu/edk2-x86_64-code.fd","/usr/share/qemu/edk2-x86_64-code.fd" \
            "/usr/share/edk2-ovmf/x64/OVMF_CODE.fd","/usr/share/edk2-ovmf/x64/OVMF_VARS.fd"
          )
          ;;
      esac

    # declare -p ovmfs

      # Attempt each EFI_CODE file one by one, selecting the corresponding code and vars
      # when an existing file is found.

      _IFS=$IFS
      IFS=","
      for f in "${ovmfs[@]}"; do

        #printf "\n\n f is  %s"  "$f"    # MOD   TODO  redo ALL this EFI section & associatively

        # shellcheck disable=SC2086

        set -- $f;
        if [ -e "${1}" ]; then
          EFI_CODE="${1}"
          EFI_EXTRA_VARS="${2}"

          #printf "\n\n  Set: EFI_CODE is %s  EFI_EXTRA_VARS are %s \n"  "$EFI_CODE"  "$EFI_EXTRA_VARS"
        fi

     done
      IFS=$_IFS
    fi
    
    
    #EFI_CODE="/usr/share/OVMF/OVMF_CODE_4M.ms.fd"
    #EFI_EXTRA_VARS="/usr/share/OVMF/OVMF_VARS_4M.ms.fd"

    #EFI_CODE="/usr/share/OVMF/OVMF_CODE_4M.secboot.fd"
    #EFI_EXTRA_VARS="/usr/share/OVMF/OVMF_VARS_4M.fd"



    if [ -z "${EFI_CODE}" ] || [ ! -e "${EFI_CODE}" ]; then
      if [ "$secureboot" == "on" ]; then
        echo "ERROR! SecureBoot was requested but no SecureBoot capable firmware was found."
      else
        echo "ERROR! EFI boot requested but no EFI firmware found."
      fi
      echo "       Please install OVMF firmware."
      exit 1
    fi
    if [ -n "${EFI_EXTRA_VARS}" ]; then
      if [ ! -e "${EFI_EXTRA_VARS}" ]; then
        echo " - EFI:      ERROR! EFI_EXTRA_VARS file ${EFI_EXTRA_VARS} does not exist."
        exit 1
      fi
      efi_vars "${EFI_EXTRA_VARS}" "${EFI_VARS}"
    fi

    # Make sure EFI_VARS references an actual, writeable, file
    if [ ! -f "${EFI_VARS}" ] || [ ! -w "${EFI_VARS}" ]; then
      echo " - EFI:      ERROR! ${EFI_VARS} is not a regular file or not writeable."
      echo "             Deleting ${EFI_VARS}. Please re-run quickemu."
      rm -f "${EFI_VARS}"
      exit 1
    fi

    # If EFI_CODE references a symlink, resolve it to the real file.
    if [ -L "${EFI_CODE}" ]; then
      echo " - EFI:      WARNING! ${EFI_CODE} is a symlink."
      echo -n "             Resolving to... "
      EFI_CODE=$(realpath "${EFI_CODE}")
      echo "${EFI_CODE}"
    fi
    BOOT_STATUS="EFI (${guest_os^}), OVMF (${EFI_CODE}), SecureBoot (${secureboot})."
  else
    BOOT_STATUS="Legacy BIOS (${guest_os^})"
    boot="legacy"
    secureboot="off"
  fi



  echo " - BOOT:     ${BOOT_STATUS}"

  # Make any OS specific adjustments
  case ${guest_os} in
    batocera|*bsd|freedos|haiku|linux)
      CPU="-cpu host,kvm=on"
      if [ "${HOST_CPU_VENDOR}" == "AuthenticAMD" ]; then
        CPU="${CPU},topoext"
      fi

      if [ "${guest_os}" == "freebsd" ] || [ "${guest_os}" == "ghostbsd" ]; then
        MOUSE="usb"
      elif [ "${guest_os}" == "batocera" ] || [ "${guest_os}" == "freedos" ] || [ "${guest_os}" == "haiku" ]; then
        MACHINE_TYPE="pc"
        NET_DEVICE="rtl8139"
      fi

      if [ "${guest_os}" == "freedos" ] ; then
        # fix for #382
        SMM="on"
      fi

      if [ -z "${disk_size}" ]; then
        disk_size="16G"
      fi
      ;;
    kolibrios|reactos)
      CPU="-cpu qemu32,kvm=on"
      if [ "${HOST_CPU_VENDOR}" == "AuthenticAMD" ]; then
        CPU="${CPU},topoext"
      fi
      MACHINE_TYPE="pc"
      case ${guest_os} in
        kolibrios) NET_DEVICE="rtl8139";;
        reactos)
          NET_DEVICE="e1000"
          KEYBOARD="ps2"
          ;;
      esac
      ;;
    macos)
      #https://www.nicksherlock.com/2020/06/installing-macos-big-sur-on-proxmox/
      # A CPU with SSE4.1 support is required for >= macOS Sierra
      # A CPU with AVX2 support is required for >= macOS Ventura
      case ${macos_release} in
        ventura)
          if check_cpu_flag sse4_1 && check_cpu_flag avx2; then
            CPU="-cpu Haswell,kvm=on,vendor=GenuineIntel,+hypervisor,+invtsc,+kvm_pv_eoi,+kvm_pv_unhalt"
          else
            echo "ERROR! macOS ${macos_release} requires a CPU with SSE 4.1 and AVX2 support."
            exit 1
          fi
          ;;
        *)
          if check_cpu_flag sse4_1; then
            # Used in past versions: +movbe,+smep,+xgetbv1,+xsavec,+avx2
            # Warn on AMD:           +fma4,+pcid
            CPU="-cpu Penryn,kvm=on,vendor=GenuineIntel,+aes,+avx,+bmi1,+bmi2,+fma,+hypervisor,+invtsc,+kvm_pv_eoi,+kvm_pv_unhalt,+popcnt,+ssse3,+sse4.2,vmware-cpuid-freq=on,+xsave,+xsaveopt,check"
          else
            echo "ERROR! macOS ${macos_release} requires a CPU with SSE 4.1 support."
            exit 1
          fi
          ;;
      esac

      OSK=$(echo "bheuneqjbexolgurfrjbeqfthneqrqcyrnfrqbagfgrny(p)NccyrPbzchgreVap" | tr 'A-Za-z' 'N-ZA-Mn-za-m')
      # Disable S3 support in the VM to prevent macOS suspending during install
      GUEST_TWEAKS="-no-hpet -global kvm-pit.lost_tick_policy=discard -global ICH9-LPC.disable_s3=1 -device isa-applesmc,osk=${OSK}"

      # Tune Qemu optimisations based on the macOS release, or fallback to lowest
      # common supported options if none is specified.
      #   * VirtIO Block Media doesn't work in High Sierra (at all) or the Mojave (Recovery Image)
      #   * VirtIO Network is supported since Big Sur
      #   * VirtIO Memory Balloning is supported since Big Sur (https://pmhahn.github.io/virtio-balloon/)
      #   * VirtIO RNG is supported since Big Sur, but exposed to all guests by default.
      case ${macos_release} in
        catalina)
          BALLOON=""
          MAC_DISK_DEV="ide-hd,bus=ahci.2"
          NET_DEVICE="vmxnet3"
          USB_HOST_PASSTHROUGH_CONTROLLER="usb-ehci"
          ;;
        big-sur|monterey|ventura)
          BALLOON="-device virtio-balloon"
          MAC_DISK_DEV="ide-hd,bus=ahci.2"
          NET_DEVICE="virtio-net"
          USB_HOST_PASSTHROUGH_CONTROLLER="nec-usb-xhci"
          GUEST_TWEAKS="${GUEST_TWEAKS} -global nec-usb-xhci.msi=off"
          ;;
        *)
          # Backwards compatibility if no macos_release is specified.
          # Also safe catch all for High Sierra and Mojave
          BALLOON=""
          MAC_DISK_DEV="ide-hd,bus=ahci.2"
          NET_DEVICE="vmxnet3"
          USB_HOST_PASSTHROUGH_CONTROLLER="usb-ehci"
          ;;
      esac

      if [ -z "${disk_size}" ]; then
        disk_size="96G"
      fi
      ;;

    ##  WINDOWS & HYPERVISOR  (needs its own special highlight ...)

    windows)

      # qe 4.4/4.5 - CPU="-cpu host,kvm=on,+hypervisor,+invtsc,l3-cache=on,migratable=no,hv_passthrough"

      # dec 14 2022 introduces here : if [ "${QEMU_VER_SHORT}" -gt 60 ]; then

			# https://github.com/quickemu-project/quickemu/commit/23982c3f9da2c99d3fae333a0c6e89677bded499
			
			# Tests for -gt 60 but standard quickemu also exits the script if -lt 60 ...  
      
      # Appears something very specific about qemu ver 6.0.0 ...  (??)  REVIEW 
        
      # MOD: add recipe settings. If recipe use that, otherwise use standard 'quickemu 4.5 defaults'. 

			if [[ $WinHyperV_RC  ]]; then  CPU="$WinHyperV_RC"

      elif [[ $QEMU_VER_SHORT == "60" ]]; then 
      
        CPU="-cpu host,kvm=on,+hypervisor,+invtsc,l3-cache=on,migratable=no,hv_frequencies,kvm_pv_unhalt,hv_reenlightenment,\
        hv_relaxed,hv_spinlocks=8191,hv_stimer,hv_synic,hv_time,hv_vapic,hv_vendor_id=1234567890ab,hv_vpindex"

      else  CPU="-cpu host,kvm=on,+hypervisor,+invtsc,l3-cache=on,migratable=no,hv_passthrough"

      fi

      #  See https://github.com/quickemu-project/quickemu/issues/572  &  https://www.qemu.org/docs/master/system/i386/hyperv.html

      # From qemu docs hyperv:

      # Note: hv-passthrough flag only enables enlightenments which are known to QEMU (have corresponding ‘hv-‘ flag) 
      # and copies hv-spinlocks and hv-vendor-id values from KVM to QEMU. hv-passthrough overrides all other ‘hv-‘ settings on the command line. 
      # Also, enabling this flag effectively prevents migration as the list of enabled enlightenments may differ between target and destination hosts.

      # This above may account for VM's built with quickemu 4.2 not working with 4.3  ... ?  YMMV

      # Also of interest:  https://bbs.archlinux.org/viewtopic.php?id=233713   https://kevinlocke.name/bits/2021/12/10/windows-11-guest-virtio-libvirt/


      if [ "${HOST_CPU_VENDOR}" == "AuthenticAMD" ]; then
        CPU="${CPU},topoext"
      fi
      # Disable S3 support in the VM to ensure Windows can boot with SecureBoot enabled
      #  - https://wiki.archlinux.org/title/QEMU#VM_does_not_boot_when_using_a_Secure_Boot_enabled_OVMF

      GUEST_TWEAKS="-no-hpet -global kvm-pit.lost_tick_policy=discard -global ICH9-LPC.disable_s3=1"

      if [ -z "${disk_size}" ]; then
        disk_size="64G"
      fi
      SMM="on"
      ;;

    ##  EO WINDOWS

    *)
      CPU="-cpu host,kvm=on"
      NET_DEVICE="rtl8139"
      if [ -z "${disk_size}" ]; then
        disk_size="32G"
      fi
      echo "WARNING! Unrecognised guest OS: ${guest_os}"
      ;;

  esac



  echo " - Disk:     ${disk_img} (${disk_size})"
  if [ ! -f "${disk_img}" ]; then
      # If there is no disk image, create a new image.
      mkdir -p "${VMDIR}" 2>/dev/null
      case ${preallocation} in
        off|metadata|falloc|full) true;;
        *)
          echo "ERROR! ${preallocation} is an unsupported disk preallocation option."
          exit 1;;
      esac

      # https://blog.programster.org/qcow2-performance
      if ! ${QEMU_IMG} create -q -f qcow2 -o lazy_refcounts=on,preallocation="${preallocation}" "${disk_img}" "${disk_size}"; then
        echo "ERROR! Failed to create ${disk_img}"
        exit 1
      fi

      if [ -z "${iso}" ] && [ -z "${img}" ]; then
        echo "ERROR! You haven't specified a .iso or .img image to boot from."
        exit 1
      fi
      echo "             Just created, booting from ${iso}${img}"
      DISK_USED="no"
  elif [ -e "${disk_img}" ]; then
    # Check there isn't already a process attached to the disk image.
    if ! ${QEMU_IMG} info "${disk_img}" >/dev/null; then
      echo "             Failed to get \"write\" lock. Is another process using the disk?"
      exit 1
    else
      # Only check disk image size if preallocation is off
      if [ "${preallocation}" == "off" ]; then
        DISK_CURR_SIZE=$(stat -c%s "${disk_img}")
        if [ "${DISK_CURR_SIZE}" -le "${DISK_MIN_SIZE}" ]; then
          echo "             Looks unused, booting from ${iso}${img}"
          if [ -z "${iso}" ] && [ -z "${img}" ]; then
            echo "ERROR! You haven't specified a .iso or .img image to boot from."
            exit 1
          fi
        else
          DISK_USED="yes"
        fi
      else
        DISK_USED="yes"
      fi
    fi
  fi

  if [ "${DISK_USED}" == "yes" ] && [ "${guest_os}" != "kolibrios" ]; then
    # If there is a disk image that appears to be used do not boot from installation media.
    iso=""
    img=""
  fi

  # Has the status quo been requested?
  if [ "${STATUS_QUO}" == "-snapshot" ]; then
    if [ -z "${img}" ] && [ -z "${iso}" ]; then
      echo "             Existing disk state will be preserved, no writes will be committed."
    fi
  fi

  if [ -n "${iso}" ] && [ -e "${iso}" ]; then
    echo " - Boot ISO: ${iso}"
  elif [ -n "${img}" ] && [ -e "${img}" ]; then
    echo " - Recovery: ${img}"
  fi

  if [ -n "${fixed_iso}" ] && [ -e "${fixed_iso}" ]; then
    echo " - CD-ROM:   ${fixed_iso}"
  fi

  # Setup the appropriate audio device based on the display output
  # https://www.kraxel.org/blog/2020/01/qemu-sound-audiodev/
  case ${OUTPUT} in
    none|spice|spice-app) AUDIO_DEV="spice,id=audio0";;
    *) AUDIO_DEV="pa,id=audio0";;
  esac

  # Determine a sane resolution for Linux guests.
  if [ "${guest_os}" == "linux" ]; then
    local X_RES=1152
    local Y_RES=648
    if [ "${XDG_SESSION_TYPE}" == "x11" ]; then
      local LOWEST_WIDTH=""
      if [ -z "${SCREEN}" ]; then
        LOWEST_WIDTH=$(xrandr --listmonitors | grep -v Monitors | cut -d' ' -f4 | cut -d'/' -f1 | sort | head -n1)
      else
        LOWEST_WIDTH=$(xrandr --listmonitors | grep -v Monitors | grep "^ ${SCREEN}:" | cut -d' ' -f4 | cut -d'/' -f1 | head -n1)
      fi
      if [ "${FULLSCREEN}" ]; then
        if [ -z "${SCREEN}" ]; then
          X_RES=$(xrandr --listmonitors | grep -v Monitors | cut -d' ' -f4 | cut -d'/' -f1 | sort | head -n1)
          Y_RES=$(xrandr --listmonitors | grep -v Monitors | cut -d' ' -f4 | cut -d'/' -f2 | cut -d'x' -f2 | sort | head -n1)
        else
          X_RES=$(xrandr --listmonitors | grep -v Monitors | grep "^ ${SCREEN}:" | cut -d' ' -f4 | cut -d'/' -f1 | head -n1)
          Y_RES=$(xrandr --listmonitors | grep -v Monitors | grep "^ ${SCREEN}:" | cut -d' ' -f4 | cut -d'/' -f2 | cut -d'x' -f2 | head -n1)
        fi
      elif [ "${LOWEST_WIDTH}" -ge 3840 ]; then
        X_RES=3200
        Y_RES=1800
      elif [ "${LOWEST_WIDTH}" -ge 2560 ]; then
        X_RES=2048
        Y_RES=1152
      elif [ "${LOWEST_WIDTH}" -ge 1920 ]; then
        X_RES=1664
        Y_RES=936
      elif [ "${LOWEST_WIDTH}" -ge 1280 ]; then
        X_RES=1152
        Y_RES=648
      fi
    fi
  fi

  # https://www.kraxel.org/blog/2019/09/display-devices-in-qemu/

  if [ "${guest_os}" == "linux" ]; then
    case ${OUTPUT} in
      none|spice|spice-app)
        DISPLAY_DEVICE="virtio-gpu";;
      *)
        DISPLAY_DEVICE="virtio-vga";;
    esac

  elif [ "${guest_os}" == "macos" ]; then
    # qxl-vga supports seamless mouse and sane resolutions if only one scanout
    # is used. Which is whay '-vga none' is added to the QEMU command line.
    DISPLAY_DEVICE="qxl-vga"

  elif [ "${guest_os}" == "windows" ]; then
      case ${OUTPUT} in

      # virtio-gpu "works" with gtk but is limited to 1024x1024 and exhibits other issues.
      # https://kevinlocke.name/bits/2021/12/10/windows-11-guest-virtio-libvirt/#video

      gtk|none|spice) DISPLAY_DEVICE="qxl-vga";;
      sdl|spice-app)  DISPLAY_DEVICE="virtio-vga";;

      # sdl|spice-app)  DISPLAY_DEVICE="bochs-display";;

      # https://www.kraxel.org/blog/2019/09/display-devices-in-qemu/#bochs-display
      # recommends this for UEFI  REVIEW  #  MOD add ?  Or add option if guest virtio is present?  "-device bochs-display"
      # seems to work better with "virtio-vga" and checking the virtio-iso for driver updates ??

    esac

  else
    DISPLAY_DEVICE="qxl-vga"
  fi

  # Map Quickemu OUTPUT to QEMU -display
  case ${OUTPUT} in
    gtk)        DISPLAY_RENDER="${OUTPUT},grab-on-hover=on,zoom-to-fit=off,gl=${gl}";;
    none|spice) DISPLAY_RENDER="none";;
    sdl)        DISPLAY_RENDER="${OUTPUT},gl=${gl}";;
    spice-app)  DISPLAY_RENDER="${OUTPUT},gl=${gl}";;
    *)          DISPLAY_RENDER="${OUTPUT}";;
  esac

  # https://www.kraxel.org/blog/2021/05/virtio-gpu-qemu-graphics-update/   

  if [[ $gl == "on" ]] && [[ $DISPLAY_DEVICE == "virtio-vga" ]]; then

    if [[ $QEMU_VER_SHORT -ge 61 ]]; then DISPLAY_DEVICE="${DISPLAY_DEVICE}-gl"

    else  DISPLAY_DEVICE="${DISPLAY_DEVICE},virgl=on" ; fi

    echo " - Display:  ${OUTPUT^^}, ${DISPLAY_DEVICE}, GL (${gl}), VirGL (on)"

  else

    echo " - Display:  ${OUTPUT^^}, ${DISPLAY_DEVICE}, GL (${gl}), VirGL (off)"

  fi

  # Build the video configuration
  VIDEO="-device ${DISPLAY_DEVICE}"

  # Try and coerce the display resolution for Linux guests only.
  if [ "${guest_os}" == "linux" ]; then
    VIDEO="${VIDEO},xres=${X_RES},yres=${Y_RES}"
  fi

  # Allocate VRAM to VGA devices
  case ${DISPLAY_DEVICE} in
    bochs-display) VIDEO="${VIDEO},vgamem=67108864";;
    qxl|qxl-vga) VIDEO="${VIDEO},ram_size=65536,vram_size=65536,vgamem_mb=64";;
    ati-vga|cirrus-vga|VGA) VIDEO="${VIDEO},vgamem_mb=64";;
  esac

  # Configure multiscreen if max_outputs was provided in the .conf file
  if [ -v max_outputs ]; then
    VIDEO="${VIDEO},max_outputs=${max_outputs}"
  fi

  # Run QEMU with '-vga none' to avoid having two scanouts, one for VGA and
  # another for virtio-vga-gl. This works around a GTK assertion failure and
  # allows seamless mouse in macOS when using the qxl-vga device.
  # https://www.collabora.com/news-and-blog/blog/2021/11/26/venus-on-qemu-enabling-new-virtual-vulkan-driver/
  # https://github.com/quickemu-project/quickemu/issues/222
  VGA="-vga none"

  # Add fullscreen options
  VIDEO="${VGA} ${VIDEO} ${FULLSCREEN}"

  # Set the hostname of the VM
  local NET="user,hostname=${VMNAME}"

  echo -n "" > "${VMDIR}/${VMNAME}.ports"

  if [ -z "${SSH_PORT}" ]; then
    # Find a free port to expose ssh to the guest
    SSH_PORT=$(get_port 22220 9)
  fi

  if [ -n "${SSH_PORT}" ]; then
    echo "ssh,${SSH_PORT}" >> "${VMDIR}/${VMNAME}.ports"
    NET="${NET},hostfwd=tcp::${SSH_PORT}-:22"
    echo " - ssh:      On host:  ssh user@localhost -p ${SSH_PORT}"
  else
    echo " - ssh:      All ssh ports have been exhausted."
  fi

  # Have any port forwards been requested?
  if (( ${#port_forwards[@]} )); then
    echo " - PORTS:    Port forwards requested:"
    for FORWARD in "${port_forwards[@]}"; do
      HOST_PORT=$(echo "${FORWARD}" | cut -d':' -f1)
      GUEST_PORT=$(echo "${FORWARD}" | cut -d':' -f2)
      echo "              - ${HOST_PORT} => ${GUEST_PORT}"
      NET="${NET},hostfwd=tcp::${HOST_PORT}-:${GUEST_PORT}"
      NET="${NET},hostfwd=udp::${HOST_PORT}-:${GUEST_PORT}"
    done
  fi

  if [ "${OUTPUT}" == "none" ] || [ "${OUTPUT}" == "spice" ] || [ "${OUTPUT}" == "spice-app" ]; then
    local SPICE="disable-ticketing=on"
    # gl=on can be use with 'spice' too, but only over local connections (not tcp ports)
    if [ "${OUTPUT}" == "spice-app" ]; then
      SPICE+=",gl=${gl}"
    fi

    # TODO: Don't use ports so local-only connections can be used with gl=on
    if [ -z "${SPICE_PORT}" ]; then
      # Find a free port for spice
      SPICE_PORT=$(get_port 5930 9)
    fi

    if [ -z "${SPICE_PORT}" ]; then
      echo " - SPICE:    All SPICE ports have been exhausted."
      if [ "${OUTPUT}" == "none" ] || [ "${OUTPUT}" == "spice" ] || [ "${OUTPUT}" == "spice-app" ]; then
        echo "             ERROR! Requested SPICE display, but no SPICE ports are free."
        exit 1
      fi
    else
      if [ "${OUTPUT}" == "spice-app" ]; then
        echo " - SPICE:    Enabled"
      else
        echo "spice,${SPICE_PORT}" >> "${VMDIR}/${VMNAME}.ports"
        echo -n " - SPICE:    On host:  spicy --title \"${VMNAME}\" --port ${SPICE_PORT}"
        if [ "${guest_os}" != "macos" ] && [ -n "${PUBLIC}" ]; then
          echo -n " --spice-shared-dir ${PUBLIC}"
        fi
        echo "${FULLSPICY}"
        SPICE="${SPICE},port=${SPICE_PORT},addr=127.0.0.1"
      fi
    fi
  fi

  if [ -n "${PUBLIC}" ]; then
    case ${guest_os} in
      macos)
        if [ "${OUTPUT}" == "none" ] || [ "${OUTPUT}" == "spice" ] || [ "${OUTPUT}" == "spice-app" ]; then
          # Reference: https://gitlab.gnome.org/GNOME/phodav/-/issues/5
          echo " - WebDAV:   On guest: build spice-webdavd (https://gitlab.gnome.org/GNOME/phodav/-/merge_requests/24)"
          echo " - WebDAV:   On guest: Finder -> Connect to Server -> http://localhost:9843/"
        fi
        ;;
      *)
        echo " - WebDAV:   On guest: dav://localhost:9843/";;
    esac
  fi

  if [ "${guest_os}" != "windows" ] && [ -n "${PUBLIC}" ]; then
    echo -n " - 9P:       On guest: "
    if [ "${guest_os}" == "linux" ]; then
      echo "sudo mount -t 9p -o trans=virtio,version=9p2000.L,msize=104857600 ${PUBLIC_TAG} ~/$(basename "${PUBLIC}")"
    elif [ "${guest_os}" == "macos" ]; then
      # PUBLICSHARE needs to be world writeable for seamless integration with
      # macOS. Test if it is world writeable, and prompt what to do if not.
      echo "sudo mount_9p ${PUBLIC_TAG}"
      if [ "${PUBLIC_PERMS}" != "drwxrwxrwx" ]; then
        echo " - 9P:       On host:  chmod 777 ${PUBLIC}"
        echo "             Required for macOS integration 👆"
      fi
    fi
  fi

  # If smbd is available and ~/Public is present export it to the guest via samba
  if [[ -e "/usr/sbin/smbd" && -n ${PUBLIC} ]]; then
      NET="${NET},smb=${PUBLIC}"
      echo " - smbd:     On guest: smb://10.0.2.4/qemu"
  fi

  enable_usb_passthrough

  echo "#!/usr/bin/env bash" > "${VMDIR}/${VMNAME}.sh"

  # Start TPM
  if [ "${tpm}" == "on" ]; then
    local tpm_args=()
    # shellcheck disable=SC2054
    tpm_args+=(socket
            --ctrl type=unixio,path="${VMDIR}/${VMNAME}.swtpm-sock"
            --terminate
            --tpmstate dir="${VMDIR}"
            --tpm2)
    echo "${SWTPM} ${tpm_args[*]} &" >> "${VMDIR}/${VMNAME}.sh"
    ${SWTPM} "${tpm_args[@]}" >> "${VMDIR}/${VMNAME}.log" &
    echo " - TPM:      ${VMDIR}/${VMNAME}.swtpm-sock (${!})"
    sleep 0.25
  fi

  # Boot the VM
  local args=()

  # shellcheck disable=SC2054,SC2206,SC2140
  args+=(-name ${VMNAME},process=${VMNAME} -pidfile "${VMDIR}/${VMNAME}.pid"
         -enable-kvm -machine ${MACHINE_TYPE},smm=${SMM},vmport=off ${GUEST_TWEAKS}
         ${CPU} ${SMP}
         -m ${RAM_VM} ${BALLOON}
         ${VIDEO} -display ${DISPLAY_RENDER}
         -audiodev ${AUDIO_DEV}
         -device intel-hda -device hda-duplex,audiodev=audio0
         -rtc base=localtime,clock=host,driftfix=slew)

  # Only enable SPICE is using SPICE display
  # shellcheck disable=SC2054

  if [ "${OUTPUT}" == "none" ] || [ "${OUTPUT}" == "spice" ] || [ "${OUTPUT}" == "spice-app" ]; then
    args+=(-spice ${SPICE}
           -device virtio-serial-pci
           -chardev socket,id=agent0,path="${VMDIR}/${VMNAME}-agent.sock",server=on,wait=off
           -device virtserialport,chardev=agent0,name=org.qemu.guest_agent.0
           -chardev spicevmc,id=vdagent0,name=vdagent
           -device virtserialport,chardev=vdagent0,name=com.redhat.spice.0
           -chardev spiceport,id=webdav0,name=org.spice-space.webdav.0
           -device virtserialport,chardev=webdav0,name=org.spice-space.webdav.0)
  fi

  # shellcheck disable=SC2054

  args+=(-device virtio-rng-pci,rng=rng0
         -object rng-random,id=rng0,filename=/dev/urandom
         -device ${USB_HOST_PASSTHROUGH_CONTROLLER},id=spicepass
         -chardev spicevmc,id=usbredirchardev1,name=usbredir
         -device usb-redir,chardev=usbredirchardev1,id=usbredirdev1
         -chardev spicevmc,id=usbredirchardev2,name=usbredir
         -device usb-redir,chardev=usbredirchardev2,id=usbredirdev2
         -chardev spicevmc,id=usbredirchardev3,name=usbredir
         -device usb-redir,chardev=usbredirchardev3,id=usbredirdev3
         -device pci-ohci,id=smartpass
         -device usb-ccid
         -chardev spicevmc,id=ccid,name=smartcard
         -device ccid-card-passthru,chardev=ccid
         )

  # setup usb-controller
  [ -z "${USB_CONTROLLER}" ] && USB_CONTROLLER="$usb_controller"
  if [ "${USB_CONTROLLER}" == "ehci" ]; then
    args+=(-device usb-ehci,id=input)
  elif [ "${USB_CONTROLLER}" == "xhci" ]; then
    args+=(-device qemu-xhci,id=input)
  elif [ -z "${USB_CONTROLLER}" ] || [ "${USB_CONTROLLER}" == "none" ]; then
    # add nothing
    :
  else
    echo "WARNING! Unknown usb-controller value: '${USB_CONTROLLER}'"
  fi

  # setup keyboard
  # @INFO: must be set after usb-controller
  [ -z "${KEYBOARD}" ] && KEYBOARD="$keyboard"
  if [ "${KEYBOARD}" == "usb" ]; then
    args+=(-device usb-kbd,bus=input.0)
  elif [ "${KEYBOARD}" == "virtio" ]; then
    args+=(-device virtio-keyboard)
  elif [ "${KEYBOARD}" == "ps2" ] || [ -z "${KEYBOARD}" ]; then
    # add nothing, default is ps/2 keyboard
    :
  else
    echo "WARNING! Unknown keyboard value: '${KEYBOARD}'; Fallback to ps2"
  fi

  # setup keyboard_layout
  # @INFO: When using the VNC display, you must use the -k parameter to set the keyboard layout if you are not using en-us.
  [ -z "${KEYBOARD_LAYOUT}" ] && KEYBOARD_LAYOUT="$keyboard_layout"
  if [ -n "${KEYBOARD_LAYOUT}" ]; then
    args+=(-k ${KEYBOARD_LAYOUT})
  fi

  # Check for device availability. qemu will fail to start otherwise ( REVIEW ) 
	  if [ -n "${BRAILLE}" ]; then
    # shellcheck disable=SC2054
    args+=(-chardev braille,id=brltty
           -device usb-braille,id=usbbrl,chardev=brltty)
  fi

  # setup mouse
  # @INFO: must be set after usb-controller
  [ -z "${MOUSE}" ] && MOUSE="$mouse"
  if [ "${MOUSE}" == "usb" ]; then
    args+=(-device usb-mouse,bus=input.0)
  elif [ "${MOUSE}" == "tablet" ]; then
    args+=(-device usb-tablet,bus=input.0)
  elif [ "${MOUSE}" == "virtio" ]; then
    args+=(-device virtio-mouse)
  elif [ "${MOUSE}" == "ps2" ] || [ -z "${MOUSE}" ]; then
    # add nothing, default is ps/2 mouse
    :
  else
    echo "WARNING! Unknown mouse value: '${MOUSE}; Fallback to ps2'"
  fi

  # $bridge backwards compatibility for Quickemu <= 4.0
  if [ -n "${bridge}" ]; then
    network="${bridge}"
  fi

  if [ "${network}" == "none" ]; then
    # Disbale all networking
    echo " - Network:  Disabled"
    args+=(-nic none)
  elif [ "${network}" == "restrict" ]; then
    echo " - Network:  Restricted (${NET_DEVICE})"
    # shellcheck disable=SC2054,SC2206
    args+=(-device ${NET_DEVICE},netdev=nic -netdev ${NET},restrict=y,id=nic)
  elif [ -n "${network}" ]; then
    # Enable bridge mode networking
    echo " - Network:  Bridged (${network})"

    # If a persistent MAC address is provided, use it.
    local MAC=""
    if [ -n "${macaddr}" ]; then
      MAC=",mac=${macaddr}"
    fi

    # shellcheck disable=SC2054,SC2206
    args+=(-nic bridge,br=${network},model=virtio-net-pci${MAC})
  else
    echo " - Network:  User (${NET_DEVICE})"
    # shellcheck disable=SC2054,SC2206
    args+=(-device ${NET_DEVICE},netdev=nic -netdev ${NET},id=nic)
  fi

  # Add the disks
  # - https://turlucode.com/qemu-disk-io-performance-comparison-native-or-threads-windows-10-version/
  if [[ "${boot}" == *"efi"* ]]; then
    # shellcheck disable=SC2054
    args+=(-global driver=cfi.pflash01,property=secure,value=on
           -drive if=pflash,format=raw,unit=0,file="${EFI_CODE}",readonly=on
           -drive if=pflash,format=raw,unit=1,file="${EFI_VARS}")
  fi

  if [ -n "${iso}" ] && [ "${guest_os}" == "freedos" ]; then
    # FreeDOS reboots after partitioning the disk, and QEMU tries to boot from disk after first restart
    # This flag sets the boot order to cdrom,disk. It will persist until powering down the VM
    args+=(-boot order=dc)
  elif [ -n "${iso}" ] && [ "${guest_os}" == "kolibrios" ]; then
    # Since there is bug (probably) in KolibriOS: cdrom indexes 0 or 1 make system show an extra unexisting iso, so we use index=2
    # shellcheck disable=SC2054
    args+=(-drive media=cdrom,index=2,file="${iso}")
    iso=""
  elif [ -n "${iso}" ] && [ "${guest_os}" == "reactos" ]; then
    # https://reactos.org/wiki/QEMU
    # shellcheck disable=SC2054
    args+=(-boot order=d
           -drive if=ide,index=2,media=cdrom,file="${iso}")
    iso=""
  elif [ -n "${iso}" ] && [ "${guest_os}" == "windows" ] && [ -e "${VMDIR}/unattended.iso" ]; then
    # Attach the unattended configuration to Windows guests when booting from ISO
    # shellcheck disable=SC2054
    args+=(-drive media=cdrom,index=2,file="${VMDIR}/unattended.iso")
  fi

  if [ -n "${floppy}" ]; then
    # shellcheck disable=SC2054
    args+=(-drive if=floppy,format=raw,file="${floppy}")
  fi

  if [ -n "${iso}" ]; then
    # shellcheck disable=SC2054
    args+=(-drive media=cdrom,index=0,file="${iso}")
  fi

  if [ -n "${fixed_iso}" ]; then
    # shellcheck disable=SC2054
    args+=(-drive media=cdrom,index=1,file="${fixed_iso}")
  fi

  if [ "${guest_os}" == "macos" ]; then
    # shellcheck disable=SC2054
    args+=(-device ahci,id=ahci
           -device ide-hd,bus=ahci.0,drive=BootLoader,bootindex=0,rotation_rate=1
           -drive id=BootLoader,if=none,format=qcow2,discard=unmap,file="${MAC_BOOTLOADER}")

    if [ -n "${img}" ]; then
      # shellcheck disable=SC2054
      args+=(-device ide-hd,bus=ahci.1,drive=RecoveryImage,rotation_rate=1
             -drive id=RecoveryImage,if=none,format=raw,discard=unmap,file="${img}")
    fi

    # shellcheck disable=SC2054,SC2206
    args+=(-device ${MAC_DISK_DEV},drive=SystemDisk,rotation_rate=1
           -drive id=SystemDisk,if=none,format=qcow2,discard=unmap,file="${disk_img}" ${STATUS_QUO})

  elif [ "${guest_os}" == "kolibrios" ]; then
    # shellcheck disable=SC2054,SC2206
    args+=(-device ahci,id=ahci
           -device ide-hd,bus=ahci.0,drive=SystemDisk
           -drive id=SystemDisk,if=none,format=qcow2,file="${disk_img}" ${STATUS_QUO})

  elif [ "${guest_os}" == "batocera" ] ; then
    # shellcheck disable=SC2054,SC2206
    args+=(-device virtio-blk-pci,drive=BootDisk
           -drive id=BootDisk,if=none,format=raw,file="${img}"
           -device virtio-blk-pci,drive=SystemDisk
           -drive id=SystemDisk,if=none,format=qcow2,file="${disk_img}" ${STATUS_QUO})

  elif [ "${guest_os}" == "reactos" ]; then
    # https://reactos.org/wiki/QEMU
    # shellcheck disable=SC2054,SC2206
    args+=(-drive if=ide,index=0,media=disk,file="${disk_img}")

  elif [ "${guest_os}" == "windows" ]; then
      # shellcheck disable=SC2054,SC2206
      args+=(-device virtio-blk-pci,drive=SystemDisk
           -drive id=SystemDisk,if=none,format=qcow2,discard=unmap,file="${disk_img}" ${STATUS_QUO})

  else
    # shellcheck disable=SC2054,SC2206
    args+=(-device virtio-scsi-pci,id=scsi0
          -device scsi-hd,drive=SystemDisk,bus=scsi0.0,lun=0,rotation_rate=1
          -drive id=SystemDisk,if=none,format=qcow2,discard=unmap,file="${disk_img}" ${STATUS_QUO})
  fi

  # https://wiki.qemu.org/Documentation/9psetup
  # https://askubuntu.com/questions/772784/9p-libvirt-qemu-share-modes
  if [ "${guest_os}" != "windows" ] && [ -n "${PUBLIC}" ]; then
      # shellcheck disable=SC2054
      args+=(-fsdev local,id=fsdev0,path="${PUBLIC}",security_model=mapped-xattr
             -device virtio-9p-pci,fsdev=fsdev0,mount_tag="${PUBLIC_TAG}")
  fi

  if [ -n "${USB_PASSTHROUGH}" ]; then
    # shellcheck disable=SC2054,SC2206
    args+=(-device ${USB_HOST_PASSTHROUGH_CONTROLLER},id=hostpass
          ${USB_PASSTHROUGH})
  fi

  if [ "${tpm}" == "on" ] && [ -S "${VMDIR}/${VMNAME}.swtpm-sock" ]; then
      # shellcheck disable=SC2054
      args+=(-chardev socket,id=chrtpm,path="${VMDIR}/${VMNAME}.swtpm-sock"
            -tpmdev emulator,id=tpm0,chardev=chrtpm
            -device tpm-tis,tpmdev=tpm0)
  fi

  if [ -z "${MONITOR}" ]; then
    MONITOR="${monitor:-none}"
  fi

  if [ -z "${MONITOR_TELNET_HOST}" ]; then
    MONITOR_TELNET_HOST="${monitor_telnet_host:-localhost}"
  fi
  if [ -z "${MONITOR_TELNET_PORT}" ]; then
    MONITOR_TELNET_PORT="${monitor_telnet_port}"
  fi
  if [ -n "${MONITOR_TELNET_PORT}" ] &&  ! is_numeric "${MONITOR_TELNET_PORT}"; then
    echo "ERROR: telnet-port must be a number!"
    exit 1
  fi

  if [ "${MONITOR}" == "none" ]; then
    args+=(-monitor none)
    echo " - Monitor:  (off)"
  elif [ "${MONITOR}" == "telnet" ]; then
    # Find a free port to expose monitor-telnet to the guest
    local temp_port=
    temp_port="$(get_port "$MONITOR_TELNET_PORT" 9)"
    if [ -z "${temp_port}" ]; then
      echo " - Monitor:  All Monitor-Telnet ports have been exhausted."
    else
      MONITOR_TELNET_PORT="${temp_port}"
      args+=(-monitor telnet:${MONITOR_TELNET_HOST}:${MONITOR_TELNET_PORT},server,nowait)
      echo " - Monitor:  On host:  telnet ${MONITOR_TELNET_HOST} ${MONITOR_TELNET_PORT}"
      echo "monitor-telnet,${MONITOR_TELNET_PORT},${MONITOR_TELNET_HOST}" >> "${VMDIR}/${VMNAME}.ports"
    fi
  elif [ "${MONITOR}" == "socket" ]; then
    args+=(-monitor unix:${VM_MONITOR_SOCKETPATH},server,nowait)
    echo " - Monitor:  On host:  nc -U \"${VM_MONITOR_SOCKETPATH}\""
    echo "             or     :  socat -,echo=0,icanon=0 unix-connect:${VM_MONITOR_SOCKETPATH}"
  else
    echo "ERROR! \"${MONITOR}\" is an unknown monitor option."
    exit 1
  fi

  if [ -z "${SERIAL}" ]; then
    SERIAL="${serial:-none}"
  fi

  if [ -z "${SERIAL_TELNET_HOST}" ]; then
    SERIAL_TELNET_HOST="${serial_telnet_host:-localhost}"
  fi
  if [ -z "${SERIAL_TELNET_PORT}" ]; then
    SERIAL_TELNET_PORT="${serial_telnet_port}"
  fi
  if [ -n "${SERIAL_TELNET_PORT}" ] &&  ! is_numeric "${SERIAL_TELNET_PORT}"; then
    echo "ERROR: serial-port must be a number!"
    exit 1
  fi

  if [ "${SERIAL}" == "none" ]; then
    args+=(-serial none)
  elif [ "${SERIAL}" == "telnet" ]; then
    # Find a free port to expose serial-telnet to the guest
    local temp_port=
    temp_port="$(get_port "$SERIAL_TELNET_PORT" 9)"
    if [ -z "${temp_port}" ]; then
      echo " - Serial:   All Serial-Telnet ports have been exhausted."
    else
      SERIAL_TELNET_PORT="${temp_port}"
      args+=(-serial telnet:${SERIAL_TELNET_HOST}:${SERIAL_TELNET_PORT},server,nowait)
      echo " - Serial:   On host:  telnet ${SERIAL_TELNET_HOST} ${SERIAL_TELNET_PORT}"
      echo "serial-telnet,${SERIAL_TELNET_PORT},${SERIAL_TELNET_HOST}" >> "${VMDIR}/${VMNAME}.ports"
    fi
  elif [ "${SERIAL}" == "socket" ]; then
    args+=(-serial unix:${VM_SERIAL_SOCKETPATH},server,nowait)
    echo " - Serial:   On host:  nc -U \"${VM_SERIAL_SOCKETPATH}\""
    echo "             or     :  socat -,echo=0,icanon=0 unix-connect:${VM_SERIAL_SOCKETPATH}"
  else
    echo "ERROR! \"${SERIAL}\" is an unknown serial option."
    exit 1
  fi

  # shellcheck disable=SC2054,SC2206

  if [[ $EXTRA_ARGS ]]; then

      # UNquoted so that the args become separated 
      
      #  TEMP  (using std quickemu array method for now)
    
      args+=($EXTRA_ARGS)
  fi

  # The OSK parameter contains parenthesis, they need to be escaped in the shell
  # scripts. The vendor name, Quickemu Project, contains a space. It needs to be
  # double-quoted.

  SHELL_ARGS="${args[*]}"
  SHELL_ARGS="${SHELL_ARGS//\(/\\(}"
  SHELL_ARGS="${SHELL_ARGS//)/\\)}"
  SHELL_ARGS="${SHELL_ARGS//Quickemu Project/\"Quickemu Project\"}"


  # MOD: Show all the compiled qemu & swmtp arguments as a human readable list

  #  TODO   tee the original vm_boot messages into a text file that can be repeat shown (& recorded)

  # declare -p args

  QemuArgsFile="${VMDIR}/QemuArgsList.txt"

  printf "\n\n  Present Working Directory:  %s"  "$(pwd)" > "$QemuArgsFile"
  printf "\n\n  Qemu:  %s\n" "$QEMU" >> "$QemuArgsFile"

  for a in "${args[@]}"; do
    if [[ "$a" == -dev* ]]; then printf "\n\n  %s" "$a" >> "$QemuArgsFile"
    elif [[ "$a" == -* ]]; then printf "\n  %s" "$a" >> "$QemuArgsFile" 
    else printf " %s" "$a" >> "$QemuArgsFile"
    fi
  done

  if [[ $tpm == "on" ]]; then 
    printf "\n\n\n  Secure Boot:  %s \n\n  %s " "$SWTPM" "${tpm_args[*]}" >> "$QemuArgsFile"
  else    
    printf "\n\n\n  Secure Boot:  Not Set" >> "$QemuArgsFile"
  fi
    printf "\n\n\n"  >> "$QemuArgsFile"
    
  if [[ $ShowQemuArgs ]]; then
    # MOD:
    cat "$QemuArgsFile"
    printColor "  [enter] to continue  [b] to go back \n\n"
    read -rp " >  " BreakOnShowQemuArgs
    printf "\n\n"
    [[ $BreakOnShowQemuArgs == "b" ]] && return
  fi

  ## BOOT:

  if [[ ${VM_UP} -eq 0 ]] ; then

    case "${OUTPUT}" in
      # Enable grab-on-hover for SDL: https://github.com/quickemu-project/quickemu/issues/541
      sdl) export SDL_MOUSE_FOCUS_CLICKTHROUGH=1;;
    esac

    echo "${QEMU}" "${SHELL_ARGS}" >> "${VMDIR}/${VMNAME}.sh"

    # -D  https://qemu.readthedocs.io/en/latest/system/invocation.html  ??

    ${QEMU} "${args[@]}" -D "${VMDIR}/${VMNAME}.log"  &

    # sleep 0.25   (mod ??)

    # MOD  allow time for any system boot messages to show, before tidying up screen output

    [[ $CLI ]] && sleep 40 && printf "\n"


  fi

  # end of function vm_boot
}



function start_viewer {

  ErrNo=0

  if [ "${VIEWER}" == "none" ]; then

    echo > /dev/null

    # MOD  Can add-in options for SDL be made ?  REVIEW  

  else

    # If output is 'none' then SPICE was requested.
    if [ "${OUTPUT}" == "spice" ]; then
      if [ "${VIEWER}" == "remote-viewer" ]; then
        # show via viewer: remote-viewer

        if [ -n "${PUBLIC}" ]; then
          echo " - Viewer:   ${VIEWER} --title \"${VMNAME}\" --spice-shared-dir \"${PUBLIC}\" ${FULLSPICY} \"spice://localhost:${SPICE_PORT}\" >/dev/null 2>&1 &"
          ${VIEWER} --title "${VMNAME}" --spice-shared-dir "${PUBLIC}" "${FULLSPICY}" "spice://localhost:${SPICE_PORT}" >/dev/null 2>&1 &
          ErrNo=$?
        else
          echo " - Viewer:   ${VIEWER} --title \"${VMNAME}\" ${FULLSPICY} \"spice://localhost:${SPICE_PORT}\" >/dev/null 2>&1 &"
          ${VIEWER} --title "${VMNAME}" "${FULLSPICY}" "spice://localhost:${SPICE_PORT}" >/dev/null 2>&1 &
          ErrNo=$?
        fi

      elif [ "${VIEWER}" == "spicy" ]; then
        # show via viewer: spicy

        if [ -n "${PUBLIC}" ]; then
          echo " - Viewer:   ${VIEWER} --title \"${VMNAME}\" --port \"${SPICE_PORT}\" --spice-shared-dir \"${PUBLIC}\" \"${FULLSPICY}\" >/dev/null 2>&1 &"
          ${VIEWER} --title "${VMNAME}" --port "${SPICE_PORT}" --spice-shared-dir "${PUBLIC}" "${FULLSPICY}" >/dev/null 2>&1 &
          ErrNo=$?
        else
          echo " - Viewer:   ${VIEWER} --title \"${VMNAME}\" --port \"${SPICE_PORT}\" \"${FULLSPICY}\" >/dev/null 2>&1 &"
          ${VIEWER} --title "${VMNAME}" --port "${SPICE_PORT}" "${FULLSPICY}" >/dev/null 2>&1 &
          ErrNo=$?
        fi
      fi
      if [ $ErrNo -ne 0 ]; then
        echo "WARNING! Could not start viewer(${VIEWER}) Err: $ErrNo"
      fi
    fi
  fi
}



function display_param_check() {
  if [ "${OUTPUT}" != "gtk" ] && [ "${OUTPUT}" != "none" ] && [ "${OUTPUT}" != "sdl" ] && [ "${OUTPUT}" != "spice" ] && [ "${OUTPUT}" != "spice-app" ]; then
    echo "ERROR! Requested output '${OUTPUT}' is not recognised."
    exit 1
  fi
}

function viewer_param_check() {
  if [ "${VIEWER}" != "none" ] && [ "${VIEWER}" != "spicy" ] && [ "${VIEWER}" != "remote-viewer" ]; then
    echo "ERROR! Requested viewer '${VIEWER}' is not recognised."
    exit 1
  fi
  if [ "${VIEWER}" == "spicy" ] && ! command -v spicy &>/dev/null; then
    echo "ERROR! Requested 'spicy' as viewer, but 'spicy' is not installed."
    exit 1
  elif [ "${VIEWER}" == "remote-viewer" ] && ! command -v remote-viewer &>/dev/null; then
    echo "ERROR! Requested 'remote-viewer' as viewer, but 'remote-viewer' is not installed."
    exit 1
  fi
}

function parse_ports_from_file {

    local FILE="${VMDIR}/${VMNAME}.ports"

    # shellcheck disable=SC2002
    local port_name=( $(cat "$FILE" | cut -d, -f1) )
    # shellcheck disable=SC2002
    local port_number=( $(cat "$FILE" | cut -d, -f2) )
    # shellcheck disable=SC2002
    local host_name=( $(cat "$FILE" | gawk 'FS="," {print $3,"."}') )

    for ((i=0; i<${#port_name[@]}; i++)); do
      if [ "${port_name[$i]}" == "ssh" ]; then
        SSH_PORT="${port_number[$i]}"
      elif [ "${port_name[$i]}" == "spice" ]; then
        SPICE_PORT="${port_number[$i]}"
      elif [ "${port_name[$i]}" == "monitor-telnet" ]; then
        MONITOR_TELNET_PORT="${port_number[$i]}"
        MONITOR_TELNET_HOST="${host_name[$i]}"
      elif [ "${port_name[$i]}" == "serial-telnet" ]; then
        SERIAL_TELNET_PORT="${port_number[$i]}"
        SERIAL_TELNET_HOST="${host_name[$i]}"
      fi
    done
}

function is_numeric {
    [[ "$1" =~ ^[0-9]+$ ]]
}

function monitor_send_cmd {
    local MSG="${1}"

    if [ -z "${MSG}" ]; then
        echo "WARNING! Send to QEMU-Monitor: Message empty!"
        return 1
    fi

    # Determine monitor channel
    local monitor_channel=""

    if [ -S "${VMDIR}/${VMNAME}-monitor.socket" ]; then
        monitor_channel="socket"
    elif [ -n "${MONITOR_TELNET_PORT}" ] && [ -n "${MONITOR_TELNET_HOST}" ]; then
        monitor_channel="telnet"
    else
        echo "WARNING! No qemu-monitor channel available - Couldn't send message to monitor!"
        return
    fi

    case "${monitor_channel}" in
        socket)
            echo -e " - Sending:  ${MSG}"
            echo -e "${MSG}" | socat -,shut-down unix-connect:"${VM_MONITOR_SOCKETPATH}"  > /dev/null  2>&1
            ;;
        telnet)
            echo -e " - Sending:  ${MSG}"
            echo -e "${MSG}" | socat - tcp:"${MONITOR_TELNET_HOST}":"${MONITOR_TELNET_PORT}"  > /dev/null  2>&1
            ;;
        *)
            echo "ERROR! This should never happen!"
            exit 1
            ;;
    esac

    return 0
}


#  LOAD the two main code sections of quickemu as 

#  functions:  'quickemu' & 'quickemu-actions'


function quickemu_actions () {

	if [ -n "${VM}" ] && [ -e "${VM}" ]; then
		# shellcheck source=/dev/null
		source "${VM}"
		if [ -z "${disk_img}" ]; then
			echo "ERROR! No disk_img defined."
			exit 1
		fi

		VMDIR=$(dirname "${disk_img}")
		VMNAME=$(basename "${VM}" .conf)
		# VMPATH=$(realpath "$(dirname "${VM}")") ??
		VM_MONITOR_SOCKETPATH="${VMDIR}/${VMNAME}-monitor.socket"
		VM_SERIAL_SOCKETPATH="${VMDIR}/${VMNAME}-serial.socket"

		# Backwards compatibility for ${driver_iso}
		if [ -n "${driver_iso}" ] && [ -z "${fixed_iso}" ]; then
			fixed_iso="${driver_iso}"
		fi

		# Backwards compatibility for ${disk} (size)
		if [ -n "${disk}" ]; then
			disk_size="${disk}"
		fi

		if [ -n "${display}" ]; then
			OUTPUT="${display}"
		fi

		# Set the default OUTPUT if not provided by user
		if [ -z "${OUTPUT}" ]; then
			OUTPUT="sdl"
		fi

		# Braille support requires SDL. Override OUTPUT if braille was requested.
		if [ -n "${BRAILLE}" ]; then
			OUTPUT="sdl"
		fi
		display_param_check

		if [ -z "${VIEWER}" ]; then
			VIEWER="${viewer}"
		fi
		viewer_param_check

		# Set the default 3D acceleration.
		if [ -z "${gl}" ]; then
			gl="on"
		fi

		if [ -z "${PUBLIC}" ]; then
			PUBLIC="${public_dir}"
		fi

		if [ "${PUBLIC}" == "none" ]; then
			PUBLIC=""
		else
			# PUBLICSHARE is the only directory exposed to guest VMs for file
			# sharing via 9P, spice-webdavd and Samba. This path is not configurable.
			if [ -z "${PUBLIC}" ]; then
				if command -v xdg-user-dir &>/dev/null; then
					PUBLIC=$(xdg-user-dir PUBLICSHARE)
				fi
			fi

			if [ ! -d "${PUBLIC}" ]; then
				echo "ERROR! Public directory: '${PUBLIC}' doesn't exist!"
				exit 1
			fi

			PUBLIC_TAG="Public-${USER,,}"
			# shellcheck disable=SC2012
			PUBLIC_PERMS=$(ls -ld "${PUBLIC}" | cut -d' ' -f1)
		fi

		if [ -z "${SSH_PORT}" ]; then
			SSH_PORT=${ssh_port}
		fi
		if [ -n "${SSH_PORT}" ] &&  ! is_numeric "${SSH_PORT}"; then
			echo "ERROR: ssh-port must be a number!"
			exit 1
		fi

		if [ -z "${SPICE_PORT}" ]; then
			SPICE_PORT=${spice_port}
		fi
		if [ -n "${SPICE_PORT}" ] && ! is_numeric "${SPICE_PORT}"; then
			echo "ERROR: spice-port must be a number!"
			exit 1
		fi

		# Check if VM is already running

		VM_PID=0
		VM_UP=0

		if [ -r "${VMDIR}/${VMNAME}.pid" ]; then

      # -r FILE: True if file is readable by you 
      # REVIEW (qemu SHOULD write this file while it is running & remove it when not) 
      # quickemu requests this file to get outputted by qemu at the beginning of the args declaration 
      # See https://qemu.readthedocs.io/en/latest/system/invocation.html#hxtool-9

			VM_PID=$(head -c 20 "${VMDIR}/${VMNAME}.pid")

      # test for PID 

			#kill -0 "$VM_PID"  >/dev/null 2>&1
			# if [ $? -eq 0 ]; then
      
      if [[ $( ps -p "$VM_PID" --no-headers ) ]]; then
					printColor "\n  This VM is already started! \n\n"
					VM_UP=1
			fi
		fi

		if [ "${tpm}" == "on" ]; then
			SWTPM=$(command -v swtpm)
			if [ ! -e "${SWTPM}" ]; then
				echo "ERROR! TPM is enabled, but swtpm was not found."
				exit 1
			fi
		fi

	else
		echo "ERROR! Virtual machine configuration not found."
		show_qe_api_usage
	fi

  if [[ $DELETE_DISK ]]; then
    delete_disk
    exit
  fi

  if [[ $DELETE_VM ]]; then
    delete_vm
    exit
  fi

	if [ -n "${SNAPSHOT_ACTION}" ]; then

		case ${SNAPSHOT_ACTION} in
			apply)
				snapshot_apply "${SNAPSHOT_TAG}"
				snapshot_info
				#exit
        ;;
			create)
				snapshot_create "${SNAPSHOT_TAG}"
				snapshot_info
				#exit
        ;;
			delete)
				snapshot_delete "${SNAPSHOT_TAG}"
				snapshot_info
				#exit
        ;;
			info)
				snapshot_info
				#exit
        ;;
			*)
				echo "ERROR! \"${SNAPSHOT_ACTION}\" is not a supported snapshot action."
				show_qe_api_usage;;
		esac
	fi

  # Boot VM or Do Snapshot:

  if [[ ! $SNAPSHOT_ACTION ]]; then

    if [ ${VM_UP} -eq 0 ] ; then

        vm_boot

        # For an uninstalled Windows VM, auto-skip the press-any key prompt

        if [ -n "${iso}" ] && [ "${guest_os}" == "windows" ]; then
          sleep 3.5
          monitor_send_cmd "sendkey ret"
        fi

        start_viewer

    else

        parse_ports_from_file
        start_viewer

    fi

    [ -n "${MONITOR_CMD}" ] && monitor_send_cmd "${MONITOR_CMD}"

  fi

  # end of quickemu_actions

}


function quickemu () {

	### MAIN

	# Lowercase variables are used in the VM config file only
	boot="efi"
	cpu_cores=""
	disk_img=""
	disk_size=""
	display=""
	fixed_iso=""
	floppy=""
	guest_os="linux"
	img=""
	iso=""
	macaddr=""
	macos_release=""
	network=""
	port_forwards=()
	preallocation="off"
	ram=""
	secureboot="off"
	tpm="off"
	usb_devices=()
	viewer="spicy"
	ssh_port=""
	spice_port=""
	public_dir=""
	monitor="socket"
	monitor_telnet_port="4440"
	monitor_telnet_host="localhost"
	serial="socket"
	serial_telnet_port="6660"
	serial_telnet_host="localhost"
	# options: ehci(USB2.0), xhci(USB3.0)
	usb_controller="ehci"
	# options: ps2, usb, virtio
	keyboard="usb"
	keyboard_layout="en-us"
	# options: ps2, usb, tablet, virtio
	mouse="tablet"

	BRAILLE=""
  DELETE_DISK=
  DELETE_VM=
	FULLSCREEN=""
	FULLSPICY=""
	OUTPUT=""
	PUBLIC=""
	PUBLIC_PERMS=""
	PUBLIC_TAG=""
	SCREEN=""
	SNAPSHOT_ACTION=""
	SNAPSHOT_TAG=""
	STATUS_QUO=""
	USB_PASSTHROUGH=""
	VM=""
	VMDIR=""
	VMNAME=""
	# VMPATH="" ??
	VIEWER=""
	SSH_PORT=""
	SPICE_PORT=""
	MONITOR=""
	MONITOR_TELNET_PORT=""
	MONITOR_TELNET_HOST=""
	MONITOR_CMD=""
	VM_MONITOR_SOCKETPATH=""
	VM_SERIAL_SOCKETPATH=""
	SERIAL=""
	SERIAL_TELNET_PORT=""
	SERIAL_TELNET_HOST=""
	KEYBOARD=""
	KEYBOARD_LAYOUT=""
	MOUSE=""
	USB_CONTROLLER=""


	# QEMU VERSION:  eg.  qemu-system-x86_64 --version

	#QEMU emulator version 7.0.0 (Debian 1:7.0+dfsg-7ubuntu2.1)
	#Copyright (c) 2003-2022 Fabrice Bellard and the QEMU Project developers

	QEMU_VER_LONG=$(${QEMU} -version | head -n1 | cut -d' ' -f4 | cut -d'(' -f1)

	# output eg. 7.0.0

	QEMU_VER_SHORT=$(${QEMU} -version | head -n1 | cut -d' ' -f4 | cut -d'(' -f1 | sed 's/\.//g' | cut -c1-2)

  # output eg. 70

  # REVIEW do we need a higher bar ?

	if [ "${QEMU_VER_SHORT}" -lt 60 ]; then
		echo "ERROR! Qemu 6.0.0 or newer is required, detected ${QEMU_VER_LONG}."
		exit 1
	fi

	# printColor "\n\n  QEMU = $QEMU \n\n  QEMU_VER_LONG =  $QEMU_VER_LONG \n\n  QEMU_VER_SHORT = $QEMU_VER_SHORT \n\n\n"


	## Take command line arguments

	# MOD  if [ $# -lt 1 ]; then  #  routes to menu now, so will run on a mouse click 

  if [[ $1 == "--help" ]] || [[ $1 == "-h" ]]; then
			show_qe_api_usage
			exit 0
	else
			while [ $# -gt 0 ]; do
					case "${1}" in
            --path|-path)
              shift
              ! cd "$1"  &&  printf "\n\n  Path ERROR: folder not found \n\n" && exit 1
              shift;;
						--toggle_msr_defaults|-toggle_msr_defaults)
							toggle_msr_defaults
							shift;;
						-braille|--braille)
							BRAILLE="on"
							shift;;
            -delete|--delete|-delete-disk|--delete-disk)
              DELETE_DISK=1
              shift;;
            -delete-vm|--delete-vm)
              DELETE_VM=1
              shift;;						
            -display|--display)
							OUTPUT="${2}"
							display_param_check
							shift
							shift;;
						-fullscreen|--fullscreen|-full-screen|--full-screen)
							FULLSCREEN="-full-screen"
							FULLSPICY="--full-screen"
							shift;;
						-screen|--screen)
							SCREEN="${2}"
							shift
							shift;;
						-snapshot|--snapshot)
							SNAPSHOT_ACTION="${2}"
							if [ -z "${SNAPSHOT_ACTION}" ]; then
								echo "ERROR! No snapshot action provided."
								exit 1
							fi
							shift
							SNAPSHOT_TAG="${2}"
							if [ -z "${SNAPSHOT_TAG}" ] && [ "${SNAPSHOT_ACTION}" != "info" ]; then
								echo "ERROR! No snapshot tag provided."
								exit 1
							fi
							shift
							shift;;
						-status-quo|--status-quo)
							STATUS_QUO="-snapshot"
							shift;;
						-vm|--vm)
							VM="${2}"
							shift
							shift;;
						-viewer|--viewer)
							VIEWER="${2}"
							shift
							shift;;
						-ssh-port|--ssh-port)
							SSH_PORT="${2}"
							shift
							shift;;
						-spice-port|--spice-port)
							SPICE_PORT="${2}"
							shift
							shift;;
						-public-dir|--public-dir)
							PUBLIC="${2}"
							shift
							shift;;
						-monitor|--monitor)
							MONITOR="${2}"
							shift
							shift;;
						-monitor-cmd|--monitor-cmd)
							MONITOR_CMD="${2}"
							shift
							shift;;
						-monitor-telnet-host|--monitor-telnet-host)
							MONITOR_TELNET_HOST="${2}"
							shift
							shift;;
						-monitor-telnet-port|--monitor-telnet-port)
							MONITOR_TELNET_PORT="${2}"
							shift
							shift;;
						-serial|--serial)
							SERIAL="${2}"
							shift
							shift;;
						-serial-telnet-host|--serial-telnet-host)
							SERIAL_TELNET_HOST="${2}"
							shift
							shift;;
						-serial-telnet-port|--serial-telnet-port)
							SERIAL_TELNET_PORT="${2}"
							shift
							shift;;
						-keyboard|--keyboard)
							KEYBOARD="${2}"
							shift
							shift;;
						-mouse|--mouse)
							MOUSE="${2}"
							shift
							shift;;
						-usb-controller|--usb-controller)
							USB_CONTROLLER="${2}"
							shift
							shift;;
						-show_args|--show_args|--show-qemu-args)
							ShowQemuArgs=1
							shift;;
						-h|--h|-help|--help|help)
							show_qe_api_usage;;
						*)
							echo; echo "  ERROR! \"${1}\" is not a supported parameter."
							show_qe_api_usage;;
					esac
			done
	fi

	# end of quickemu, carry out the requested actions:

	quickemu_actions

}


#  END of ADD-IN of ORIGINAL quickemu 


# quickemu-mod   Licence:  GPL3   

# Copyright (c) Alex Genovese  

# For code contributions, add-ons, bugs and updates, see:

# https://github.com/TuxVinyards

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# https://www.gnu.org/licenses 

# IF ANY MODDED CODE BECOMES USED IN THE ORIGINAL QUICKEMU PROJECT,

# OR ANY OTHER PROJECT, YOU SHOULD SHOW BOTH THE LICENCE  

# & CLEAR ATTRIBUTIONS TO THE CODE SECTIONS USED.



#  GENERAL COLOR & THEMING   (see settings)

[[ ! $X_Shade ]] &&  X_Shade="3"

#  Yellow 3 (recommended), Blue 4, Cyan 6 (brighter blue), Red 1

#  https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit

#  https://tldp.org/HOWTO/Bash-Prompt-HOWTO/x405.html



##  START of new DUAL USE functions that may be used by both the API and the menu system

printColor () {

	tput setaf "$X_Shade"

	# shellcheck disable=SC2059

	printf "$@"

	tput sgr0

}

exit () {

  # trap to keep terminal open if started by mouse click  -t secs

  printf "\n\n"

  if [[ ! $CLI ]] && [[ $1 ]]; then 

    printColor "  ERROR : [Enter] to quit  or [h] to hold terminal open \n\n"
  
    read -rp  "  >  "  -t 30  ExitTrap

  fi

  [[ ! $CLI ]] && [[ $ExitTrap == "h" ]] &&  printf "\n\n  Holding terminal open  [Enter] to quit  \n\n"  && read -rp "  >  "

  tput cnorm

  command exit "$@"

}


function_find_kvm_msr_default_and_status () {

  # outputs boths vars 'KVM_MSR_DefaultConf' & 'KVM_MSR_status' with value Y or N 

  KVM_MSR_status="$(cat /sys/module/kvm/parameters/ignore_msrs)"

  [[ ! $KVM_MSR_ModProbeFile ]] && KVM_MSR_ModProbeFile="/etc/modprobe.d/kvm-quickemu.conf"

  KVM_MSR_DefaultConf="$(cat "$KVM_MSR_ModProbeFile" 2> /dev/null)"

  [[ "$KVM_MSR_DefaultConf" == *'=Y' ]] &&  KVM_MSR_default="Y"

  [[ "$KVM_MSR_DefaultConf" == *'=N' ]] || [[ ! -e "$KVM_MSR_ModProbeFile" ]] &&  KVM_MSR_default="N"

}


toggle_msr_defaults () {

  # Modded & now reversible rewrite of original quickemu's function 'ignore_msrs_always'

  # https://www.linux-kvm.org/page/Category:Docs

  if [[ ! -d /etc/modprobe.d ]]; then

    printf "\n  ERROR! /etc/modprobe.d was not found. \n\n  See notes, it may be possible to manually create modprobe.d/kvm-quickemu.conf \n\n"

  else

    printf "\n\n  Configure default KVM behaviour for unhandled machine-specific registers"

    printf "\n\n  Normal setting is N (don't ignore) but Windows and MacOS require Y (true) 'ignore' "

    if [[ $CLI ]]; then

      function_find_kvm_msr_default_and_status

      printf "\n\n  Status:  /sys/module/kvm/parameters/ignore_msrs = %s   Current Default = %s"   "$KVM_MSR_status"  "$KVM_MSR_default"

    fi

    [[ ! $KVM_MSR_ModProbeFile ]] && KVM_MSR_ModProbeFile="/etc/modprobe.d/kvm-quickemu.conf"

    if [[ ! -e "$KVM_MSR_ModProbeFile" ]]; then 

      printf "\n\n  \'%s\'  needs to be created "  "$KVM_MSR_ModProbeFile" 

    fi

    printf "\n\n  [y] to set Y  [n] to set N  [b] to go back \n\n"

    read -rp  "  > "  Set_MSR_defaults

    # set .conf file content & update initramfs in all kernels (y/n or none)

    if [[ $Set_MSR_defaults == "y" ]]; then

      printf "\n\n  Updating 'initramfs' may take a moment or two ... \n\n"

      echo "options kvm ignore_msrs=Y" | sudo tee "$KVM_MSR_ModProbeFile"
      sudo update-initramfs -k all -u

    elif [[ $Set_MSR_defaults == "n" ]]; then

      printf "\n\n  Updating 'initramfs' may take a moment or two ... \n\n"

      echo "options kvm ignore_msrs=N" | sudo tee "$KVM_MSR_ModProbeFile"
      sudo update-initramfs -k all -u

    fi

  fi

  [[ $CLI ]] && exit 1

}


## LOAD MENU BASED MOD FUNCTIONS (end of dual purpose functions)  


show_kvm_sudo_security_note () {

  printf     "\n  QuickEmu-Mod requires 'sudo' permissions to echo true or false to 'ignore_msrs'"
  
  printf   "\n\n  This allows you to create a temporary MSRS status that may be changed at any time,"
  
  printf   "\n\n  allowing you to match the selected guest VM that you want to run."

  
  printf "\n\n\n  If you have concerns about this script, or about giving elevated permissions, "
  
  printf   "\n\n  then the script should be checked or you should issue these commands manually:"
  
  printf   "\n\n  Open a side terminal, use shift-crtl-c to copy the displayed command & shift-crtl-v to paste it. "
  
  printf   "\n\n  Elevated permissions will then exist only in the side terminal & cease once it is closed. "

  printf   "\n\n  Return to q-mod & select 'leave as'.  Q-Mod will re-read msrs settings & auto-update. "


  printf "\n\n\n  If you mainly use Windows or Mac VM's then a file '.../modprobe.d/kvm-quickemu.conf' "
  
  printf   "\n\n  can be created to modify the load up settings. Quickemu-Mod has a new built in function"

  printf   "\n\n  that can set this up & also allows future adjustments may be made."
  
  printf   "\n\n  Or it may be carried out manually...  See settings, script & further notes for details."
 
  printf   "\n\n"
  
}


select_msr_config () {

  # Only displays if MSRS/OS conflict exists

  while true ; do

    if [[ $MSR_offer == "Y" ]]; then

      printf "\n\n  Set Y : echo 1 | sudo tee /sys/module/kvm/parameters/ignore_msrs ? "

      printColor "\n\n  [enter] to set Y "

      printf "  [n]  leave as N"

    else

      printf "\n\n  Set N : echo 0 | sudo tee /sys/module/kvm/parameters/ignore_msrs ? "

      printColor "\n\n  [enter] to set N "

      printf "  [y]  leave as Y"

    fi
    
    if [[ $KVM_MSR_selector == "h" ]]; then printf "   [d] to set the load up defaults \n\n"

    else  printf "   [h] see help  \n\n" 

    fi
    
    read -rp "  >  "  KVM_MSR_selector
    
    printf "\n"

    if [[ ! $KVM_MSR_selector ]]; then

      [[ $MSR_offer == "Y" ]] &&  echo 1 | sudo tee /sys/module/kvm/parameters/ignore_msrs  2> /dev/null   &&  break

      [[ $MSR_offer == "N" ]] &&  echo 0 | sudo tee /sys/module/kvm/parameters/ignore_msrs  2> /dev/null   &&  break

    fi

    [[ $KVM_MSR_selector == "h" ]] && show_kvm_sudo_security_note    

    if [[ $KVM_MSR_selector == "d" ]]; then

      toggle_msr_defaults  

      if [[ $Set_MSR_defaults == "b" ]]; then 
      
        Set_MSR_defaults= 
        KVM_MSR_status="$(cat /sys/module/kvm/parameters/ignore_msrs)"

        printColor "\n\n  Make TEMPORARY setting adjustments to MSRS ?"

        printf "\n\n  Current Status:  /sys/module/kvm/parameters/ignore_msrs =  %s "  "$KVM_MSR_status"

      else break ; fi 

    fi

    [[ $KVM_MSR_selector == "y" ]] || [[ $KVM_MSR_selector == "n" ]]  &&  break   

  done

  KVM_MSR_selector=

}


function_conf_error () {

  printf "\n\n  ERROR  Quickemu-Mod  Settings, VM folder & conf file(s)"

  if [[ $1 ]] ; then printf "\n\n  Please check %s settings, location & content ... \n\n"  "$1"

  else printf "\n\n  Please check the settings and re-run this script ... \n\n" ; fi
  
  if [[ "$1" == 'QMOD COMMAND'* ]]; then printColor "\n\n  [q] to quit \n\n"
    
  else   printColor "\n\n  [Enter] to edit the settings   [q] to quit \n\n" ; fi

  read -rp "  >  "

  [[ $REPLY == "q" ]] && printf "\n\n" && command exit 

  qmod_edit_settings

}


function_Select_VM () {  

  SelectArrayError=


  if [[ $ByPass_VM_Array_Checker ]]; then

    # ignore array check if API is supplying  "path/folder"  "file.conf"  as further checks are made

    printf "\n\n  ByPassing VM_Array Checker ... "

  else 

    # Check for .conf locations & List the VM's 

    VM_Number=0

    while [[ ${VM_Array[$VM_Number,0]} ]] ; do

      if [[ ! -d "${VM_Array[$VM_Number,0]}" ]]; then 

        printf "\n\n  ERROR  quickemu-mod folder not found: \n\n  %s \n\n" "${VM_Array[$VM_Number,0]}"

        function_conf_error  "folder $VM_Number" 
        SelectArrayError=1
        break 

      else

        if [[ -e "${VM_Array[$VM_Number,0]}/${VM_Array[$VM_Number,1]}" ]]; then 

          [[ ! $ByPass_VM_Array_Selector ]] && printf "\n\n %2d  %s " "$VM_Number" "${VM_Array[$VM_Number,0]}/${VM_Array[$VM_Number,1]}"

        else

          printf "\n\n  ERROR  quickemu-mod ' .conf ' not found: \n\n  %s \n\n" "${VM_Array[$VM_Number,0]}/${VM_Array[$VM_Number,1]}"

          function_conf_error  "config $VM_Number" 
          SelectArrayError=1
          break

        fi

      fi

      ((VM_Number+=1))

    done
    
    ##  Add scans of current & listed VM folders for other potential '.conf' files

    [[ ! ${VM_Array[0,0]} ]] && VM_Number=0    

    CurrentFolder_Conf_String="$(ls "$CurrentFolder/"*.conf 2> /dev/null)"

    CurrentFolder_Conf_String=${CurrentFolder_Conf_String//"$CurrentFolder/"/}

    mapfile -t  CurrentFolder_Conf_Array  <<< "$CurrentFolder_Conf_String"


    if [[ $Default_VM_Folder != "$CurrentFolder" ]]; then

      DefaultFolder_Conf_String="$(ls "$Default_VM_Folder/"*.conf 2> /dev/null)"

      DefaultFolder_Conf_String=${DefaultFolder_Conf_String//"$Default_VM_Folder/"/}

      mapfile -t  DefaultFolder_Conf_Array  <<< "$DefaultFolder_Conf_String"

    fi

    if [[ $Second_VM_Folder ]] && [[ $Second_VM_Folder != "$CurrentFolder" ]]; then

      SecondFolder_Conf_String="$(ls "$Second_VM_Folder/"*.conf 2> /dev/null)"

      SecondFolder_Conf_String=${SecondFolder_Conf_String//"$Second_VM_Folder/"/}

      mapfile -t  SecondFolder_Conf_Array  <<< "$SecondFolder_Conf_String"

    fi

    if [[ $Third_VM_Folder ]] && [[ $Third_VM_Folder != "$CurrentFolder" ]]; then

      ThirdFolder_Conf_String="$(ls "$Third_VM_Folder/"*.conf 2> /dev/null)"

      ThirdFolder_Conf_String=${ThirdFolder_Conf_String//"$Third_VM_Folder/"/}

      mapfile -t  ThirdFolder_Conf_Array  <<< "$ThirdFolder_Conf_String"

    fi


    #echo; declare -p CurrentFolder_Conf_Array

    #[[ ${DefaultFolder_Conf_Array[0]} ]] && echo && declare -p DefaultFolder_Conf_Array

    #[[ ${SecondFolder_Conf_Array[0]} ]] && echo && declare -p SecondFolder_Conf_Array


    function_VM_array_add_confs () {

      # where $1 is 'VM_Path' and  $2 is 'VM_Conf' to test against the existing list (non-sparse)

      # adds to VM array & lists, if submitted item has not been already listed 

      local i=0

      while [[ ${VM_Array[$i,0]} ]]; do

        ArrFolderFile="${VM_Array[$i,0]}/${VM_Array[$i,1]}"

        TestFolderFile="$1/$2"

        [[ $ArrFolderFile == "$TestFolderFile" ]] && return
        
        ((i+=1))

      done

      if grep -q 'guest_os=' "$TestFolderFile" ; then

        VM_Array[$VM_Number,0]="$1" 
        VM_Array[$VM_Number,1]="$2" 

        [[ ! $ByPass_VM_Array_Selector ]] && printf "\n\n %2d  %s " "$VM_Number" "${VM_Array[$VM_Number,0]}/${VM_Array[$VM_Number,1]}"

        ((VM_Number+=1))

      fi

    }


    if [[ ${CurrentFolder_Conf_Array[0]} ]]; then 
    
      for TestFile in "${CurrentFolder_Conf_Array[@]}"; do function_VM_array_add_confs  "$CurrentFolder" "$TestFile" ; done

    fi

    if [[ ${DefaultFolder_Conf_Array[0]} ]]; then 
    
      for TestFile in "${DefaultFolder_Conf_Array[@]}"; do function_VM_array_add_confs  "$Default_VM_Folder" "$TestFile" ; done

    fi

    if [[ ${SecondFolder_Conf_Array[0]} ]]; then 
    
      for TestFile in "${SecondFolder_Conf_Array[@]}"; do function_VM_array_add_confs  "$Second_VM_Folder" "$TestFile" ; done

    fi

    if [[ ${ThirdFolder_Conf_Array[0]} ]]; then 
    
      for TestFile in "${ThirdFolder_Conf_Array[@]}"; do function_VM_array_add_confs  "$Third_VM_Folder" "$TestFile" ; done

    fi


    if [[ ! ${VM_Array[0,0]} ]] ; then

      function_conf_error  "VM ARRAY - No VMs found?"

      SelectArrayError=1

    fi

    # end of VM selector routine

  fi


  if [[ $ByPass_VM_Array_Selector ]] || [[ $SelectArrayError ]] ; then

    printf "\n\n  ByPassing VM_Array Selector ... "

  else 

    VM_Selection=
    VM_Conf_Dir=
    VM_Conf_File=

    printf "\n\n\n  [number] to select a VM "

    printColor "  [Enter] for %s (VM 0) \n\n"  "${VM_Array[0,1]}"

    read -rp  "  >  "  VM_Selection

    [[ ! $VM_Selection ]] &&  VM_Selection=0  

    printf "\n\n  Selecting instance %s \n\n"  "$VM_Selection"


    VM_Conf_Dir="${VM_Array[$VM_Selection,0]}"

    VM_Conf_File="${VM_Array[$VM_Selection,1]}"

  fi


  if [[ $SettingsFileAdjusted && $ByPass_VM_Array_Selector ]] || [[ $SelectArrayError ]]; then

    # Only the array checker is run after a settings edit, if a VM selection is already in place 

    printf "\n\n  Maintaining current KVM settings ... "

  else

    ## Check file/folder exists

    [[ ! -d "$VM_Conf_Dir" ]] &&  function_conf_error  "folder"  && SelectArrayError=1

    # change directory to where the VM is

    ! cd "$VM_Conf_Dir"  &&  printColor "\n\n  ERROR  .conf  folder switching \n\n" && exit 1

    [[ ! -e "$VM_Conf_File" ]] &&  function_conf_error  ".conf file" && SelectArrayError=1


    # Quickemu sets the same name to the .conf file and to the main folder 

    VM_InstanceName="${VM_Conf_File/.conf}"

    # VM_QCOW_Dir="$VM_Conf_Dir/$VM_InstanceName"

    # check that the dir contains the right files  &&  grep .conf for right content

    [[ ! $(ls "$VM_InstanceName"/*.qcow2 2> /dev/null) ]] && function_conf_error  "folder"  && SelectArrayError=1

    ! grep -q 'guest_os=' "$VM_Conf_File" && function_conf_error  ".conf file"   && SelectArrayError=1
  

    ## Check KVM parameter settings & advise according to guest OS

    KVM_MSR_selector=

    function_find_kvm_msr_default_and_status


    ## Display config settings if MSRS/OS conflict exists

    if [[ $KVM_MSR_status == "N" ]] ; then

      # usual system default = N

      if [[ "$VM_InstanceName" == *windows*  ]] ||	[[ "$VM_InstanceName" == *macos*  ]] ; then 
      
        printColor "\n\n  Selected: %s "  "$VM_InstanceName"
        
        printf " 'ignore_msrs' is recommended for Windows and Mac"  

        printf "\n\n  Status:  /sys/module/kvm/parameters/ignore_msrs = N   Default = %s"  "$KVM_MSR_default"

        MSR_offer="Y"

        select_msr_config

      fi
      
    else

      #  Status = Y  &  which is recommended for Windows & Mac 

      if [[ "$VM_InstanceName" != *windows*  ]] &&	[[ "$VM_InstanceName" != *macos*  ]] ; then

        printColor "\n\n  Selected: %s "  "$VM_InstanceName"
      
        printf " 'ignore_msrs' is only recommended for Windows and Mac"  

        printf "\n\n  Status:  /sys/module/kvm/parameters/ignore_msrs = Y   Default = %s"  "$KVM_MSR_default"

        MSR_offer="N"

        select_msr_config

      fi

    fi

  fi

  # clear any no-longer needed flags

  Select_VM=
  ByPass_VM_Array_Checker=
  ByPass_VM_Array_Selector=

  # reload if the editor was called, due to settings error

  if [[ $SelectArrayError ]]; then
  
    MainMenuChoice="refresh" 
    Select_VM=1

    [[ $VM_InstanceName ]] && ByPass_VM_Array_Selector=1

  else

    SettingsFileAdjusted=

  fi

}


print_kvm_status () {

  KVM_MSR_status="$(cat /sys/module/kvm/parameters/ignore_msrs)"

  if [[ $KVM_MSR_status == "Y" ]] ; then  
  
    printf "\n\n  KVM:  /sys/module/kvm/parameters/ignore_msrs  = Y" 

    [[ $VM_InstanceName ]] && [[ "$VM_InstanceName" != *windows* && "$VM_InstanceName" != *macos* ]] && printColor "  ERROR " 

    printf "\n"
    
  else 

    printf "\n\n  KVM:  /sys/module/kvm/parameters/ignore_msrs  = N" 

    [[ $VM_InstanceName ]] && [[ "$VM_InstanceName" == *windows* || "$VM_InstanceName" == *macos* ]] && printColor "  ERROR " 

    printf "\n"

  fi

}


KDE_ctrl_c_msg () {

  # KDE/konsole    See: https://bugs.kde.org/show_bug.cgi?id=313862

  # REVIEW remove? has ctrl-c been coded-out now?  Here mainly as a quick fix solution ...

  if [[ $XDG_SESSION_DESKTOP == "KDE" ]] || [[ $XDG_CURRENT_DESKTOP == "KDE" ]]; then   printf " - [ctrl-shift-q] to quit" 

  else printf " - [ctrl-c] to quit"  ; fi

}


function_snapshot_list() {

  printf "\n\n"

	quickemu -vm "$VM_Conf_File"  --snapshot info

}


function_KillPID_Menu() {

  tput civis

	# wait for background load & qemu messages to appear before showing menu (unless reloading)

	if [[ $KillPID_Menu_Exited ]]; then  KillPID_Menu_Exited=

  elif [[ $BreakOnShowQemuArgs ]]; then BreakOnShowQemuArgs= ; return

  else  sleep 20 ; fi
  
  if [[ ! $InstancePID ]]; then

    # belt & braces check for the PID:  

    InstancePID="$(pgrep "$VM_InstanceName")"

    # braces: qemu SHOULD write a .pid file while it is running & remove it when not  REVIEW 

    [[ ! $InstancePID ]] && InstancePID="$(cat "${VMDIR}/${VMNAME}.pid")"

  fi
	
	printf "\n  Quickemu instance on PID:  %s"  "$InstancePID"

	printf  "   [k] force close the Quickemu instance  \n\n"

  # return to menu requires VM to be shutdown first

  while true ; do 

    read -rp  "  >  " -t 1  KillPID_Menu

    if [[ $KillPID_Menu == "k" ]]; then 

      printf "\n\n"
      [[ $( ps -p "$InstancePID" --no-headers ) ]] &&  kill "$InstancePID" &
      sleep 3
      printf "\n\n"

      tput cnorm
      break

    else

      if [[ ! $( ps -p "$InstancePID" --no-headers ) ]]; then 
      
        tput cnorm 
        break 

      else

        #  Erase text and adjust cursor:   "\e[1A\r"  "\e[2K\r"  etc    See https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797
       
        printf "\r"

      fi

    fi

  done

  KillPID_Menu=

  KillPID_Menu_Exited=1

}	

qmod_edit_settings() {

  if [[ ! $TextEditor ]]; then
  
    DefaultTextEditor="$(xdg-mime query default text/plain)"

    if [[ $DefaultTextEditor ]]; then

      TextEditor="${DefaultTextEditor/.desktop/}"

    elif [[ $(type -p nano) ]] ; then 

      TextEditor="nano"

    fi

  fi

  if [[ $(type -p $TextEditor) ]]; then 

    # Run the editor: 

    # Note, can throw a complaint if 'xapps' has not not been installed, but works ...  YMMV  (2> /dev/null)

    # https://askubuntu.com/questions/1396739/failed-to-load-module-xapp-gtk3-module

    "$TextEditor" "$Q_Mod_SettingsFile"  2> /dev/null 

    SettingsFileAdjusted=1


    # Re-Read settings file & QMOD sections:

    # shellcheck disable=SC1090

    . "$Q_Mod_SettingsFile"  QMOD

    printf "\033c"


    # Flag up for main loop to run/re-run the VM array checker/selector

    Select_VM=1

    [[ $VM_InstanceName ]] &&  ByPass_VM_Array_Selector=1

  else

    printColor "\n\n  Unable to find a default or basic text editor \n\n  Try an install of 'nano' or give settings file the command name of a preferred editor ..  \n\n"

    read -rp "  > "

  fi

}


function show_quickemu_mod_help {

  printf "\n\n  QuickEmu-MOD version %s "  "$VERSION"

  printf "\n\n  For code contributions, add-ons, bugs and updates, see:"  

  printf "\n\n  https://github.com/TuxVinyards"  

  printf "\n\n  For interactive menus, start in a folder terminal:  ./quickemu-mod   or by mouse click \n\n  [enter] to return  [a] API detail \n\n"

  read -rp "  >  "  REPLY

  if [[ $REPLY == "a" ]]; then
  
    show_qe_api_usage  
    
    read -rp  "  [enter] to return >  " 

    fi
}


function_show_main_menu_header () {

  if [[ ! $VM_InstanceName ]]; then

    Select_VM=1

  else

    [[ $InstancePID ]] && [[ ! $( ps -p "$InstancePID" --no-headers ) ]] && InstancePID=

    [[ ! $InstancePID ]] && printf "\033c"
 
    printf "\n\n"

    printColor "  VM:   %s " "$VM_InstanceName" 

    if [[ "$(pwd)" == "$Default_VM_Folder" ]]; then printf "  @   %s"  "$VM_Conf_Dir"

    else  printColor "  @   %s"  "$VM_Conf_Dir" 

    fi

    print_kvm_status

  fi

}



##  QUICKEMU-MOD  menu interface  DIVIDE  ####################################################################################################


if [[ $1 ]] && [[ "$1" != *-mod* ]]  && [[ "$1" != *menu ]]  ; then

  # Using standard pre-mod quickemu Command line Interface 

  # set cli flag to alert any modded menu functions 

  CLI=1

  # run pre-mod quickemu by re-passing the CLI parameters to the new quickemu function

  quickemu "$@"

else

  ##  Start QMOD  :   

  # https://unix.stackexchange.com/questions/220330/hide-and-unhide-cursor-with-tput

  tput civis

  if [[ "$1" == *-mod* ]] || [[ "$1" == *menu ]]; then

    ##  API for .desktop starts  

    #  --mod.menu | --vm-menu  | --vm-mod  "file.conf"  --path  "path/folder"   

    while [[ $# -gt 0 ]]; do

      case "$1" in

        *-mod*|*menu)
          VM_Conf_File="$2" 
          shift
          shift ;;

        --path|-path)
          VM_Conf_Dir="$2"
          shift
          shift ;;

      esac

    done


    [[ ! $VM_Conf_Dir ]] && VM_Conf_Dir="$CurrentFolder"

    [[ ! $VM_Conf_File ]] && function_conf_error  "QMOD COMMAND LINE Instruction,"

    [[ ! -e  "$VM_Conf_Dir/$VM_Conf_File" ]] && function_conf_error  "QMOD COMMAND LINE Instruction,"

    # Selection now made, array not needed, unless reselecting, so set bypass flags for now

    ByPass_VM_Array_Checker=1

    ByPass_VM_Array_Selector=1

  fi

  printf "\033c"

  printColor "\n\n  Quickemu Mod - Virtual Machine Launcher  Version %s"  "$VERSION"

  printf "\n\n  A menu interfaced version of quickemu ..... \n\n"    


  MultiInstanceError="$(pgrep -c 'quickemu-mod')"

  if [[ $MultiInstanceError -gt 1 ]]; then 

    printColor "\n\n  ERROR more than one instance of q-mod is running \n\n"

    read -rp "  Close the other instances, then press [enter] to continue  > "

  fi

  # MAIN MENU  (select VM then choose actions to do)

  while true ; do

    MainMenuChoice=

    SnapTitle=

    SnapNumber=

    SnapName=

    function_show_main_menu_header


    if [[ $KillPID_Menu_Exited ]] || [[ $Select_VM ]] ; then

      if [[ $InstancePID ]] && [[ $( ps -p "$InstancePID" --no-headers ) ]]; then 
      
        printf "\n\n  %s is still running ..." "$VM_InstanceName"

        function_KillPID_Menu

        continue

      else 

        InstancePID=
      
        if [[ $Select_VM ]]; then  

          #declare -p VM_Array
          #echo    "  main menu loop - after Select_VM call:"
          #read -p "  VM_InstanceName is $VM_InstanceName  ByPass_VM_Array_Checker is $ByPass_VM_Array_Checker  ByPass_VM_Array_Selector is $ByPass_VM_Array_Selector"
          #echo

          function_Select_VM

          MainMenuChoice="refresh"

          #declare -p VM_Array
          #echo    "  main menu loop - after Select_VM run:"
          #read -p "  VM_InstanceName is $VM_InstanceName  ByPass_VM_Array_Checker is $ByPass_VM_Array_Checker  ByPass_VM_Array_Selector is $ByPass_VM_Array_Selector"
          #echo

        else

          printf "\n\n  %s is now shut down\n\n" "$VM_InstanceName" 

          KillPID_Menu_Exited=

        fi
      
      fi

    fi

    if [[ ! $MainMenuChoice ]]; then

      if [[ $VerboseArgs ]]; then printf  "\n\n  [v]   cancel verbose qemu args, change to just using the log file"	

      else  printf  "\n\n  [v]   show verbose qemu args before booting, change from log file only"	; fi

      printf  "\n\n  [xa]  add extra qemu args  [m] toggle msrs defaults"
      
      [[ $EXTRA_ARGS ]] && printf  "   Current Extra: \n\n  %s"  "$EXTRA_ARGS"

      printf "\n\n  [set] open settings file in text editor "

      printf "\n"

      printf  "\n\n  [vm]  reselect VM"

      printf  "\n\n  [sl]  list snapshots"

      printf  "\n\n  [sc]  create snapshot"
      
      printf  "\n\n  [sa]  apply a snapshot"

      printf  "\n\n  [sd]  delete a snapshot"

      printf "\n"

      printColor  "\n\n  [d]   start with default sdl display (useful for update re-starts)"

      printColor 	"\n\n  [s]   start with spice display (scaleable) "  

      printf "\n"

      printf  "\n\n  [h]   show help & info "

      printf  "\n\n  [q]   quit "

      printf  "\n\n\n"

      read -rp "  >  "  MainMenuChoice

    fi


    # ACTIONS: 


    # if verbose is true, then add detail

    [[ $VerboseArgs ]] && VerboseArgs="--show_args"


    if [[ $MainMenuChoice == "h" ]] ; then

      show_quickemu_mod_help

    elif [[ $MainMenuChoice == "set" ]] ; then

      qmod_edit_settings

    elif [[ $MainMenuChoice == "m" ]] ; then

      toggle_msr_defaults

    elif [[ $MainMenuChoice == "d" ]] ; then 

      printf "\n\n"

      quickemu -vm "$VM_Conf_File"  "$VerboseArgs"  
        
      printf "  SDL: Use guest based display resize. Avoid resizing with the host mouse ...\n\n"

      function_KillPID_Menu
    
          
    elif  [[ $MainMenuChoice == "s" ]] ; then

      printf "\n\n"

      quickemu -vm "$VM_Conf_File" --display spice  "$VerboseArgs" 

      function_KillPID_Menu
      
        
    elif  [[ $MainMenuChoice == "q" ]] ; then

      printf "\n\n"

      MainMenuChoice=

      break

      exit		

    elif  [[ $MainMenuChoice == "sl" ]] ; then

      function_snapshot_list

      printf "\n\n  [enter] to return to menu \n\n "
      
      read -rp "  >  "  

    
    elif  [[ $MainMenuChoice == "sc" ]] ; then

      function_snapshot_list

      printColor "\n\n  Give [title] or [enter] for date only  [b] back to menu " 

      SnapTitle=

      printf "\n\n"

      read -rp "  >  "  SnapTitle
      
      printf "\n\n"	

      [[ ! $SnapTitle ]] && SnapTitle="$(date +%b%d)"
      
      [[ $SnapTitle != "b" ]] && quickemu  -vm "$VM_Conf_File"  --snapshot create  "$SnapTitle"

      printf "\n\n  [enter] to return to menu \n\n "
      
      read -rp "  >  "  

    elif  [[ $MainMenuChoice == "sd" ]] ; then

      printColor "\n\n Quickemu-Mod Snapshot Deletion:"

      function_snapshot_list

      # Create range-selectable array 

      SnapListString="$(function_snapshot_list | grep '[0-9][0-9]:')"

      mapfile -t SnapListArrRaw <<< "$SnapListString"

      i=0

      printColor "\n\n ID  Array  Name \n\n"

      while [[ "${SnapListArrRaw[$i]}" ]]; do

        IFS=' ' read -ra SnapListArrSeparated <<< "${SnapListArrRaw[$i]}"

        printf "%2d    %2d    %s \n"  "${SnapListArrSeparated[0]}"  "$i"  "${SnapListArrSeparated[1]}"

        ((i+=1))

      done

      SnapListArrTotal=$((i-1))

      printColor "\n\n Give ARRAY number 0 to %s of snapshot or start of snapshot range to delete"  "$SnapListArrTotal"

      printf "\n\n [enter] to return to main menu "

      SnapName=
      SnapDeleteStart=
      SnapDeleteEnd=
      SnapDeleteConfirm=
      
      printf "\n\n"
      
      read -rp " >  "  SnapDeleteStart
      

      if [[ $SnapDeleteStart ]]; then

          printColor "\n\n [enter] for individual snapshot  or  ARRAY [number] for end of range (inclusive) \n\n"

          read -rp " >  "  SnapDeleteEnd

          if [[ $SnapDeleteEnd ]]; then 
          
            printf "\n Array Range = %s to %s " "$SnapDeleteStart"  "$SnapDeleteEnd"

          else         
          
            printf "\n Delete = Array entry %s " "$SnapDeleteStart"  
            
            SnapDeleteEnd="$SnapDeleteStart"

          fi

        printColor "\n\n [enter] to continue  [b] back to main menu \n\n"

        read -rp " >  "  SnapDeleteConfirm


        if [[ $SnapDeleteConfirm == "b" ]]; then

          printf "\n\n Deletion schedule has been CANCELLED"

        else
        
          SnapDeleteRangeCounter=$SnapDeleteStart

          while [[ $SnapDeleteRangeCounter -le $SnapDeleteEnd ]]; do

            IFS=' ' read -ra SnapListArrSeparated <<< "${SnapListArrRaw[$SnapDeleteRangeCounter]}"

            SnapName="${SnapListArrSeparated[1]}"

            if [[ ! $SnapName ]]; then

              printColor "\n\n ERROR with SnapShot Array List \n\n"

              exit 1

            else

              printColor "\n\n Deleting SnapShot %2d   %2d  %s \n\n"  "${SnapListArrSeparated[0]}"  "$SnapDeleteRangeCounter"  "${SnapListArrSeparated[1]}"
            
              quickemu  -vm "$VM_Conf_File"  --snapshot delete  "$SnapName"

            fi

            ((SnapDeleteRangeCounter+=1))

          done

        fi

        printf "\n\n [enter] to return to menu \n\n "
      
        read -rp " >  "  

      fi

      #  TODO  see if tiano core bios can be set to select 'misc device' instead of 'windows boot manager' 
      #        as this can cause problems when rebooting on updates
      
      #  https://github.com/tianocore/tianocore.github.io/wiki/UEFI-application

      #  https://github.com/theopolis/uefi-firmware-parser
            
    elif  [[ $MainMenuChoice == "sa" ]] ; then

      function_snapshot_list

      printColor "\n\n  Give number of snapshot to use  [enter] to return to menu "
      
      SnapNumber=
      
      printf "\n\n"
      
      read -rp "  >  "  SnapNumber
      
      printf "\n\n"	

      if [[ $SnapNumber ]]; then
      
        quickemu -vm "$VM_Conf_File"  --snapshot apply  "$SnapNumber"

        printf "\n\n  May take a moment .... \n\n"

        printColor "\n\n  Snapshot %s has been applied. \n\n"  "$SnapNumber "

      fi
    
    elif [[ $MainMenuChoice == "v" ]] ; then

      if [[ $VerboseArgs ]]; then VerboseArgs=

      else VerboseArgs=1  ; fi

    
    elif [[ $MainMenuChoice == "vm" ]] ; then

      Select_VM=1
      ByPass_VM_Array_Selector=
      ByPass_VM_Array_Checker=

    elif [[ $MainMenuChoice == "xa" ]] ; then

      MenuXA=
      MenuXA_Correct=

      printColor "\n\n  Give extra qemu arguments to use "

      printf "\n\n  Format = \"group quoted\" with single-space separated elements eg:"
      
      printf "\n\n  -device tpm-tis,tpmdev=tpm0 \n\n"

      read -rp "  > "  MenuXA

      printf "\n\n  %s %s"  "$EXTRA_ARGS" " $MenuXA"

      printf "\n\n  Is this correct y/n ? \n\n"

      read -rp "  >  "  MenuXA_Correct

      [[ $MenuXA_Correct != "n" ]] &&  EXTRA_ARGS="$EXTRA_ARGS $MenuXA"

      printf "\033c\n\n"

    else

      [[ ! $SelectArrayError ]] && printf "\n  Select: \n"

    fi

    if [[ ! $SelectArrayError ]]; then
  
      printf "\n"

      printColor "  VM:   %s " "$VM_InstanceName" 

      printf "  @   %s"  "$VM_Conf_Dir" 

    fi

  done

fi

# vim:tabstop=2:shiftwidth=2:expandtab

## 