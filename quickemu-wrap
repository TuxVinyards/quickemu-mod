#! /bin/bash 

##  Copyright (c)  Alex Genovese   https://github.com/TuxVinyards

# 	licence:  GPL3   https://www.gnu.org/licenses 

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# https://www.gnu.org/licenses 

# IF ANY MODDED CODE BECOMES USED IN THE ORIGINAL QUICKEMU PROJECT,

# OR ANY OTHER PROJECT, YOU SHOULD SHOW BOTH THE LICENCE  

# & CLEAR ATTRIBUTIONS TO THE CODE SECTIONS USED.


##  A text menu interface for the 'quickemu' project

#   https://github.com/quickemu-project/quickemu   https://gitlab.com/qemu-project/qemu

#   Users should install 'quickemu' and may set up Virtual Machines as normal.


## A wrapping script for quickemu/quickget  Part of quickemu-mod suite of scripts. 

#  See:  https://en.wikipedia.org/wiki/Wrapper_library   https://en.wikipedia.org/wiki/Adapter_pattern 


#  @2023/07/12 this script also forms the base for qqX - quickemu quickget X terminal project  

#  It may be found named as quickemu-wrap or also found as qqx or qqX   

#  NB  if interchanging qwrap & qqX you will need different settings files.

#  See:  https://github.com/TuxVinyards/qqX  &  https://github.com/TuxVinyards/quickemu-mod


#  qwrap / qqX may be installed alongside quickemu in /usr/bin  & run by typing 'qwrap' / 'qqx' or 'quickemu-wrap' 

#  It is recommended to place the wrap/mod files into the system, as below. 

#  This allows you to run them easily from any terminal & reduces the theoretical risk of any sudo calls becoming corrupted.

#  @ 05/2023  qwrap may also be started by clicking on the .conf file if the standard first .conf line is edited to point to qwrap.

#  This second mod now re-writes the original quickemu-mod as a type of full wrapper script.

#  It uses sections of quickemu for direct source & so should generally auto-update to code changes.

#  As a separate script it has its own licence and is less onerous to maintain.

#  See accompanying LICENCE text file.

#  If adding code, please refer to  http://mywiki.wooledge.org/BashGuide/Practices#Readability  



## ShellCheck global disables:

# https://www.shellcheck.net/wiki/SC2242 as it clashes with use of exit traps used to keep mouse click scripts open

#  shellcheck disable=SC2242



## Make sure shell is set during session to decimal separator of dot 

#  LC_ALL=C changes too much, just set the numeric.

#  See locale setting discussion:  https://unix.stackexchange.com/a/149129 

#  Also  https://unix.stackexchange.com/questions/62316/why-is-there-no-euro-english-locale?rq=1

#  &   http://www.unicode.org/L2/L2001/01102-POSIX15897.htm   


export "LC_NUMERIC=C"

export "LC_COLLATE=C"


##  MOD:  Standard Quickemu checks for '< 4' which at 2022/3 now needs a bump. 

#   Some ver 5 script is present in the standard release too ...

#   More Version 5 style scripting should be used:

#   See http://mywiki.wooledge.org/BashGuide/Practices#Choose_Your_Shell

if ((BASH_VERSINFO[0] < 5)); then
  printf "\n\n  Bash 5.0 or newer is needed to run this script."
  sleep 5
  exit 1
fi

if ! tput -V | grep -q ncurses 2> /dev/null; then
  printf "\n\n  Check for your OS >  \n\n  An 'ncurses' installation should normally be present. Test using 'tput -V' "
  sleep 5
  exit 1
fi


## pre-empt some of quickemu's error messages

QEMU=$(command -v qemu-system-x86_64)     
QEMU_IMG=$(command -v qemu-img)


if [[ ! $QEMU ]] || [[ ! $QEMU_IMG ]]; then
  printf "\n\n QEMU not found. Check installations of qemu-system-x86_64 and qemu-img"
  sleep 5
  exit 1
fi


ModVersion="2023.07.21"

ModName="$(basename "$0")"

if [[ $ModName == "qqx" || $ModName == "qqX" ]]; then ModName_qqX=1 ; fi


# SETTINGS   

#  If placing the main file in /usr/bin,"

#  then place the settings file as "/$HOME/.qmod_settings, OR if qqX in "/$HOME/.qqX/qqX_settings"

#  For details, see notes at start of the settings file ...

#  Use full quoted path & name if adding in a additional folder to this script or different to these defaults

#  For .conf click starts, the Positional parameters need reading to check the settings file location;

#  this would be expected to be where the specified wrap script is located as a first check


if [[ $1 == "XDG" ]]; then 

  # .desktop start  (belt & braces)

  cd "$HOME"  || printf "\n\n XDG .desktop > HOME Folder not found " 

  if [[ $(pwd) != "$HOME" ]]; then

    printf "\n\n XDG .desktop > HOME Folder not found "
    sleep 3
    exit 1

  else

    CurrentFolder="$(pwd)"
    shift

  fi

elif [[ "$1" == ?'-vm' ]]; then  

  # where test [[ $Conf_TriggerFolder ]] will also flag up if the script was .conf target started

  Conf_TriggerFolder="$(dirname "$0")"
  
  CurrentFolder="$(dirname "$2")"

else 

  CurrentFolder="$(pwd)"
  
fi


if [[ $ModName_qqX ]]; then SettingsName="qqX_settings"

else SettingsName="qmod_settings" ; fi



if [[ $Conf_TriggerFolder ]] && [[ -e "$Conf_TriggerFolder/${SettingsName}" ]]; then  

  Q_Mod_SettingsFile="$Conf_TriggerFolder/${SettingsName}"

elif [[ -e "$CurrentFolder/${SettingsName}" ]] && [[ "$CurrentFolder" != '/usr'* ]]; then  

  Q_Mod_SettingsFile="$CurrentFolder/${SettingsName}"

elif [[ -e "$CurrentFolder/.${SettingsName}" ]] && [[ "$CurrentFolder" != '/usr'* ]]; then  

  Q_Mod_SettingsFile="$CurrentFolder/.${SettingsName}"

#  

elif [[ $ModName_qqX ]]; then 

  [[ -e "$HOME/.qqX/qqX_settings" ]] && Q_Mod_SettingsFile="$HOME/.qqX/qqX_settings"

elif [[ -e "$HOME/.qmod_settings" ]] && [[ ! $ModName_qqX ]] ; then  

  Q_Mod_SettingsFile="$HOME/.qmod_settings"

elif [[ -e "$HOME/qmod_settings" ]] && [[ ! $ModName_qqX ]] ; then 

  Q_Mod_SettingsFile="$HOME/qmod_settings"

else  

  Q_Mod_SettingsFile=  

  echo; echo "  No settings file found .... " ; echo ; sleep 2
  
fi


# Declare global associative VM ARRAY & other initializing global vars

declare -gA VM_Array=()

declare -ga Extra_VM_Folder=()


# Load Settings & Array Presets  (flag QWRAP)

VM_ExecBoot=

Extra_QE_Params=

if [[ -e "$Q_Mod_SettingsFile" ]]; then

  # shellcheck disable=SC1090
    
  if [[ $ModName_qqX ]]; then source "$Q_Mod_SettingsFile" ; else source "$Q_Mod_SettingsFile"  QWRAP ; fi

else

  printf "\n\n  ERROR with settings file detection \n\n  Re-check Installation &/or Installation instructions \n\n" ; sleep 10 
  
fi



# Function to create a list of preset VM locations 

function_create_VM_folderList() {

  DefaultFolderError=
  ExtraFolderError=

  # Make sure that 'Default_VM_Folder' has a value and it exists

  [[ ! $Default_VM_Folder ]] && Default_VM_Folder="$CurrentFolder"

  if [[ ! -d "$Default_VM_Folder" ]]; then printf "\n\n  Settings ERROR:  Default Folder NOT found \n\n" ; sleep 2 ; DefaultFolderError=1 ; fi

  
  # set and clear the folder array
 
  declare -ga VM_Folder_List=( "$CurrentFolder" "$Default_VM_Folder" )


  # shellcheck disable=SC2154

  for xF in "${Extra_VM_Folder[@]}"; do

    [[ $xF ]] && VM_Folder_List+=("$xF")

    if [[ $xF ]] &&  [[ ! -d "$xF" ]] ; then 

      # if .conf targeted start, then no need to print this, 
      # unless re-selecting, in which case the error flag will create a later highlight.
    
      if [[ ! $Conf_TriggerFolder ]]; then 
      
        printf "\n\n  Settings ERROR:\n\n  Extra Folder %s NOT found \n\n"  "$xF" 
        sleep 2 

      fi

      ExtraFolderError=1

    fi

  done

}


# Now populate the list: 

function_create_VM_folderList


# But, if settings need reloading, following a settings edit or a VM deletion:

function_refresh_and_reload_VM_arrays() {

  # NB clear extra folders array

  declare -ga Extra_VM_Folder=()


  # NB clear pre-set folders array 

  declare -gA VM_Array=()


  # Re-Read settings file & pre-set folders:

  # shellcheck disable=SC1090

  if [[ $ModName_qqX ]]; then source "$Q_Mod_SettingsFile" ; else source "$Q_Mod_SettingsFile"  QWRAP ; fi

  function_create_VM_folderList  

  function_scan_VM_folderList  

  # reload screen ( REVIEW  all cases ? )

  SettingsFileAdjusted=1

  ByPass_VM_Array_Selector=1

  KVM_MSR_Error=

  printf "\033c"

  show_qmod_title

}


# Record any set ExtraArgs in case of need to reset

ExtraSetArgs="$ExtraArgs"


##  ADD QUICKGET:  Check and set the 'quickget' version, which is used in isolated wrapping mode.

#   Quickemu gets absorb wrapped & uses the internal var "$VERSION" as its ref, so use that.

[[ $QE_Version ]] && [[ ! $(type -p "$QE_Version") ]] &&  printf "\n\n  ERROR  quickemu not found \n\n  Re-check Installation &/or Installation instructions \n\n"  && sleep 10         

[[ $QG_Version ]] && [[ ! $(type -p "$QG_Version") ]] &&  printf "\n\n  ERROR  quickget not found \n\n  Re-check Installation &/or Installation instructions \n\n"   && sleep 10         


quickget() {

  # finds the right version for the standard 'quickget' call 

  if [[ $QG_Version ]]; then  eval command "$QG_Version" " $*"

  else eval command quickget " $*" ; fi
  
}


# the version number, for display purposes

QG_Wrapped_VerNumber="$(quickget "--version")"



##  START of new functions that may be used by the menu system (or by Mod API)


#  GENERAL COLOR & THEMING   (see settings)

[[ ! $X_Shade ]] &&  X_Shade="3"

#  Yellow 3 (recommended), Blue 4, Cyan 6 (brighter blue), Red 1

#  https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit

#  https://tldp.org/HOWTO/Bash-Prompt-HOWTO/x405.html

#  if source without declared shade, set default shade

[[ ! $X_Shade ]]  && X_Shade=3

echColor () {

	# for X_Shade see qqX configs

	if [[ $2 ]] ; then

		if [[ "$1" == "-n" ]] ; then
			tput setaf "$X_Shade"
			echo -n "$2"
			tput sgr0
		else
			tput setaf "$X_Shade"
			echo "$@"          			
			tput sgr0
		fi

	else
		tput setaf "$X_Shade"
		echo "$1"
		tput sgr0
	fi

}


printColor () {

	tput setaf "$X_Shade"

	# NB this calls the printf trap function, not the actual command

	# shellcheck disable=SC2059

	printf "$@"

	tput sgr0

}


## qqX chrome up  ( runs if ModName == qqX [or qqx] )

function_qqX_logo() {
echColor "  _    _   \/   "
echColor " (_|  (_|  /\ "
echColor "   |.   |.    "
}


# Variant on   http://www.figlet.org/  -f mini  (-k)   (c)  Alex Genovese


#
qqX_title="[quickemu quickget X terminal project] - Ver: $ModVersion "
#


function_qqX_logo_title() {

if [[ $1 ]]; then

	qqX_LogoTxt="$1"

else

	qqX_LogoTxt="$qqX_title"

fi

echColor "  _    _   \/   "
echColor " (_|  (_|  /\ "
echColor "   |.   |.     $qqX_LogoTxt"

}




show_mod_api_usage () {

  printColor  "\n  Command line Usage %s :  \n\n"    "$ModName"

  printf     "  %s --vm  [path/to/vms-folder/]vm-name.conf   " "$ModName"    

  printf     "\n\n  Scripts not located in /usr/bin should be in the VMs folder or a path should be supplied. "

  printf     "\n\n  Start non /usr/bin with './' eg:  ./%s "  "$ModName" 

  printf     "\n\n  Or by clicking on the .conf file:"

  printf     "\n\n  Edit the first line of the .conf to point to qwrap/qqX instead of quickemu"

  printf     "\n\n  eg. #!/usr/bin/quickemu --vm  becomes  #!/usr/bin/qwrap --vm  or similar (VM name not needed)"

  printf     "\n\n  For more complex CLI usage, try the alternative 'q-mod' script or quickemu itself."
  
  # printf    "\n\n"

}


function exit {

  # trap to keep terminal open if started by mouse click  -t secs

  # or to stop sourced quickemu quitting as 'normal' procedure   (tput resets any hidden cursors)

  if [[ $1 == "directly" ]]; then

    tput cnorm

    command exit

  elif [[ $1 ]] && [[ ! $NoExit ]]; then

    printf "\n\n"

    printColor "  ERROR : [Enter] to quit  or [h] to hold terminal open \n\n"
  
    read -rp  "  >  "  -t 30  ExitTrap

    [[ $ExitTrap == "h" ]] &&  printf "\n\n  Holding terminal open  [Enter] to quit  \n\n"  && read -rp "  >  "

    tput cnorm

    # https://unix.stackexchange.com/questions/220330/hide-and-unhide-cursor-with-tput

    command exit "$@"

  fi

  # zero the optional 'exit 1' bypass flag (if it has been set)

  NoExit=

}



## QMOD MSRS FUNCTIONS  (may also be called via the Mod API)  

function_find_kvm_msr_default_and_status () {

  # outputs boths vars 'KVM_MSR_DefaultConf' & 'KVM_MSR_status' with value Y or N 

  # finds and flags if MSRS has a config conflict

  KVM_MSR_status="$(cat /sys/module/kvm/parameters/ignore_msrs)"

  [[ ! $KVM_MSR_ModProbeFile ]] && KVM_MSR_ModProbeFile="/etc/modprobe.d/kvm-quickemu.conf"

  KVM_MSR_DefaultConf="$(cat "$KVM_MSR_ModProbeFile" 2> /dev/null)"

  [[ "$KVM_MSR_DefaultConf" == *'=Y' ]] &&  KVM_MSR_default="Y"

  [[ "$KVM_MSR_DefaultConf" == *'=N' ]] || [[ ! -e "$KVM_MSR_ModProbeFile" ]] &&  KVM_MSR_default="N"

  if [[ $VM_InstanceName ]]; then
  
    if [[ "$VM_InstanceName" == *windows*  ]] ||	[[ "$VM_InstanceName" == *macos*  ]] ; then

      if [[ $KVM_MSR_status == "N" ]]; then KVM_MSR_Error=1 ; else KVM_MSR_Error= ; fi

    elif [[ "$VM_InstanceName" != *windows*  ]] &&	[[ "$VM_InstanceName" != *macos*  ]] ; then

      if [[ $KVM_MSR_status == "Y" ]]; then KVM_MSR_Error=1 ; else KVM_MSR_Error= ; fi

    else

      KVM_MSR_Error=

    fi

  fi
}

print_kvm_status () {

  function_find_kvm_msr_default_and_status

  if [[ $KVM_MSR_status == "Y" ]] ; then  
  
    printf "\n  /sys/module/kvm/parameters/ignore_msrs  = Y" 

    if [[ $VM_InstanceName ]] && [[ $KVM_MSR_Error ]]; then 
    
      if [[ "$VM_InstanceName" == *windows*  ]] ||	[[ "$VM_InstanceName" == *macos*  ]]; then printColor "  ERROR \n" 

      else printf "  WARNING \n" 

      fi

    fi
    
  else 

    printf "\n  /sys/module/kvm/parameters/ignore_msrs  = N" 

    if [[ "$VM_InstanceName" == *windows*  ]] ||	[[ "$VM_InstanceName" == *macos*  ]]; then printColor "  ERROR \n" 

    else printf "  WARNING \n" 

    fi

  fi

}


toggle_msr_defaults () {

  # Modded & now reversible rewrite of original quickemu's function 'ignore_msrs_always'

  Verbose_MSR_dialog=1

  # https://www.linux-kvm.org/page/Category:Docs

  if [[ ! -d /etc/modprobe.d ]]; then

    printf "\n  ERROR! /etc/modprobe.d was not found. \n\n  See notes, it may be possible to manually create modprobe.d/kvm-quickemu.conf \n\n"

  else

    printColor "\n\n  Configure default, boot-up, KVM behaviour "
    
    printf "for unhandled machine-specific registers"

    printf "\n\n  Normal setting is N (don't ignore) but Windows and MacOS require Y (true) 'ignore' "
    
    function_find_kvm_msr_default_and_status

    printf "\n\n  Status:  /sys/module/kvm/parameters/ignore_msrs = %s   Current Default = %s"   "$KVM_MSR_status"  "$KVM_MSR_default"


    [[ ! $KVM_MSR_ModProbeFile ]] && KVM_MSR_ModProbeFile="/etc/modprobe.d/kvm-quickemu.conf"

    if [[ ! -e "$KVM_MSR_ModProbeFile" ]]; then 

      printf "\n\n  \'%s\'  needs to be created "  "$KVM_MSR_ModProbeFile" 

    fi

    printf "\n\n  [y] to set Y  [n] to set N  [b] to go back \n\n"

    read -rp  "  > "  Set_MSR_defaults

    # set .conf file content & update initramfs in all kernels (y/n or none)

    if [[ $Set_MSR_defaults == "y" ]]; then

      printf "\n\n  Updating 'initramfs' may take a moment or two ... \n\n"

      # As per Martin's solution in original quickemu, needs 'tee' to get this to work, 
      # but route tee's stdout to null to tidy the screen 

      echo "options kvm ignore_msrs=Y" | sudo tee "$KVM_MSR_ModProbeFile" 1> /dev/null
      sudo update-initramfs -k all -u

    elif [[ $Set_MSR_defaults == "n" ]]; then

      printf "\n\n  Updating 'initramfs' may take a moment or two ... \n\n"

      echo "options kvm ignore_msrs=N" | sudo tee "$KVM_MSR_ModProbeFile" 1> /dev/null
      sudo update-initramfs -k all -u

    fi

  fi

}


show_kvm_sudo_security_note () {

  printColor "\n  If you mainly use Windows or Mac VM's then a file '.../modprobe.d/kvm-quickemu.conf' "
  
  printf   "\n\n  can be created to modify the load up settings. %s has a new built in function"  "$ModName"

  printf   "\n\n  that can set this up & also allows future adjustments may be made."
  
  printf   "\n\n  Or it may be carried out manually...  See settings, script & further notes for details."
 
  printColor "\n\n\n  Status:  /sys/module/kvm/parameters/ignore_msrs = %s   Current Default = %s"   "$KVM_MSR_status"  "$KVM_MSR_default"
 
  printf "\n\n  Windows or MacOS should be set to 'Y' "

  printColor "\n\n\n  %s requires 'sudo' permissions to echo true or false to 'ignore_msrs'" "$ModName"
  
  printf   "\n\n  This allows you to create a temporary MSRS status that may be changed at any time,"
  
  printf   "\n\n  allowing you to match the selected guest VM that you want to run."

  
  printColor "\n\n\n  If you have concerns about this script, or about giving elevated permissions, "
  
  printf   "\n\n  then the script should be checked or you should issue these commands manually:"
  
  printf   "\n\n  Open a side terminal, use shift-crtl-c to copy the displayed command & shift-crtl-v to paste it. "
  
  printf   "\n\n  Elevated permissions will then exist only in the side terminal & cease once it is closed. "

  printf   "\n\n  Return to %s & select 'leave as'.  %s will re-read msrs settings & auto-update. "   "$ModName" "$ModName"

  printf   "\n"
  
}


select_msr_config () {

  # MSR_offer normally present if MSRS/OS conflict previously detected, 
  # however, presume selector is being used to change current status  REVIEW 

  # where KVM_MSR_status="$(cat /sys/module/kvm/parameters/ignore_msrs)"

  function_find_kvm_msr_default_and_status

  if [[ $KVM_MSR_status == "Y" ]]; then 

    if [[ "$VM_InstanceName" == *windows*  ]] ||	[[ "$VM_InstanceName" == *macos*  ]]; then  MSR_offer="N" 

    else  MSR_offer="neutral" ; fi
    
  else 
  
    MSR_offer="Y" 
    
  fi

  KVM_MSR_selector=

  [[ $KVM_MSR_selector_LoadHelp ]] && show_kvm_sudo_security_note  


  while true ; do

    if [[ $MSR_offer == "Y" ]]; then

      printf "\n\n  Set Y : echo 1 | sudo tee /sys/module/kvm/parameters/ignore_msrs ? "

      printColor "\n\n  [y] to set Y "

      printf "  [enter]  leave as N"

    elif [[ $MSR_offer == "neutral" ]]; then

      printf "\n\n  Set N : echo 0 | sudo tee /sys/module/kvm/parameters/ignore_msrs ? "

      printf "\n\n  [n] to set N "

      printColor "  [enter]  leave as Y"

    else

      printf "\n\n  Set N : echo 0 | sudo tee /sys/module/kvm/parameters/ignore_msrs ? "

      printColor "\n\n  [n] to set N "

      printf "  [enter]  leave as Y"

    fi
    
    if [[ $KVM_MSR_selector == "h" ]] || [[ $KVM_MSR_selector_LoadHelp ]] ; then printf "   [d] to set the boot defaults \n\n"

    else  printf "   [h] see help  \n\n" 

    fi
    
    read -rp "  >  "  KVM_MSR_selector
    
    printf "\n"

    [[ ! $KVM_MSR_selector ]]  &&  break  

    [[ $KVM_MSR_selector == "y" && $MSR_offer == "N" ]] || [[ $KVM_MSR_selector == "n" && $MSR_offer == "Y" ]] && break

    if [[ $KVM_MSR_selector == "y" ]] || [[ $KVM_MSR_selector == "n" ]]; then   

      # As per Martin's solution in original quickemu, needs 'tee' to get this to work, 
      # but route tee's stdout to null to tidy the screen  

      [[ $KVM_MSR_selector == "y" ]] &&  echo 1 | sudo tee /sys/module/kvm/parameters/ignore_msrs  1> /dev/null   

      [[ $KVM_MSR_selector == "n" ]] &&  echo 0 | sudo tee /sys/module/kvm/parameters/ignore_msrs  1> /dev/null  

      print_kvm_status

      printColor "\n\n\n  [enter]  to return \n\n"
      read -rp  "  > "

      break

    fi

    if [[ $KVM_MSR_selector == "d" ]]; then

      toggle_msr_defaults  

      if [[ $Set_MSR_defaults == "b" ]]; then 
      
        Set_MSR_defaults= 
        print_kvm_status
        printColor "\n\n\n  Make TEMPORARY setting adjustments to MSRS ?"

      else 
        function_find_kvm_msr_default_and_status
        break 
      fi 

    fi

  done

  KVM_MSR_selector=
  KVM_MSR_selector_LoadHelp=

}

msrs_conflict_check_resolver() {  

  # Do a check ...

  function_find_kvm_msr_default_and_status
    
  # Display & Offer config settings if MSRS/OS CONFLICT exists

  if [[ $KVM_MSR_status == "N" ]] ; then

    # usual system default = N

    if [[ "$VM_InstanceName" == *windows*  ]] ||	[[ "$VM_InstanceName" == *macos*  ]] ; then 

      [[ ! $ByPass_VM_Array_Selector ]] && printf "\033c"
    
      printColor "\n\n  Selected: %s "  "$VM_InstanceName"
      
      printf " 'ignore_msrs' is set & is recommended for Windows and Mac"  

      MSR_offer="Y"

      select_msr_config

      function_find_kvm_msr_default_and_status

      if [[ $KVM_MSR_status == "N" ]]; then KVM_MSR_Error=1 ; else KVM_MSR_Error= ; fi

    fi
    
  else

    #  Status = Y  &  which is only recommended for Windows & Mac 

    if [[ "$VM_InstanceName" != *windows*  ]] &&	[[ "$VM_InstanceName" != *macos*  ]] ; then

      [[ ! $ByPass_VM_Array_Selector ]] && printf "\033c"

      printColor "\n\n  Selected: %s "  "$VM_InstanceName"
    
      printf "\n\n 'ignore_msrs' is set:  can be okay for other OS's but is normally used only with Windows and Mac"  

      MSR_offer="N"

      select_msr_config

      function_find_kvm_msr_default_and_status

      if [[ $KVM_MSR_status == "Y" ]]; then KVM_MSR_Error=1 ; else KVM_MSR_Error= ; fi

    fi

  fi

}

#   End of MSRS functions


##  Start ADD-IN of ORIGINAL quickemu functions & the needed variables

#   Technically, this script absorbs rather than wraps. 

#   The original code remains basically as is but some calls get re-routed via new functions ....


## Load the right version of quickemu  (from settings)

# shellcheck disable=SC2154

if [[ $QE_Version ]]; then QuickEmuSource="$QE_Version" ; else QuickEmuSource="/usr/bin/quickemu" ; fi

# shellcheck disable=SC2154

if [[ ! $(type -p "$QuickEmuSource") ]] ; then

  printf "\n\n  QUICKEMU not found. See https://github.com/quickemu-project/quickemu "

  printColor  "\n\n  ERROR  Settings or Installation FilePath:\n\n  %s \n\n"  "$QuickEmuSource"

  exit  hold

fi


QE_StartFuncsPoint=$(grep -n -m 1 'function' "$QuickEmuSource" | cut -d ':' -f 1)

# grep -n : print line number with the output lines   -m : stop after NUM selected lines

((QE_StartFuncsPoint -= 1))

QE_EOfuncsPoint=$(grep -n '### MAIN' "$QuickEmuSource" | cut -d ':' -f 1)

QE_EOfuncsTrim=$((QE_EOfuncsPoint - QE_StartFuncsPoint -1))

tail +"$QE_StartFuncsPoint" "$QuickEmuSource" | head -"$QE_EOfuncsTrim"  > "/tmp/qmod-functions-temp"

source "/tmp/qmod-functions-temp" 


# Quickemu Variables (set & clear)

QE_VarsEndPoint=$(grep -n '# Take command line arguments' "$QuickEmuSource" | cut -d ':' -f 1)

QE_varsLines=$((QE_VarsEndPoint - QE_EOfuncsPoint))

tail +"$QE_EOfuncsPoint" "$QuickEmuSource" | head -"$QE_varsLines"  > "/tmp/qmod-qe-all-vars-temp"

source "/tmp/qmod-qe-all-vars-temp"


# quickemu_vars have to be cleared before every call to quickemu as the base code is normally set to be run once & exit

# create function to refresh the rewritables

QE_rw_Vars_StartPoint=$(grep -n -m 1 -e 'readonly' "/tmp/qmod-qe-all-vars-temp" | cut -d ':' -f 1)

((QE_rw_Vars_StartPoint -=2))

head -"$QE_rw_Vars_StartPoint" "/tmp/qmod-qe-all-vars-temp"  > "/tmp/qmod-qe-rw-vars-temp"

function clear_quickemu_vars {

  source "/tmp/qmod-qe-rw-vars-temp"

}

clear_quickemu_vars



## Overwrite Original Functions Source, as required

declare -f vm_boot  >  "/tmp/qmod-function-vm_boot-orig-temp"

# shellcheck disable=SC2016

QE_qemuCallPoint=$(grep -n -m 1 -e '${QEMU} "${args' "/tmp/qmod-function-vm_boot-orig-temp" | cut -d ':' -f 1)

QE_vm_bootLength=$(wc -l < "/tmp/qmod-function-vm_boot-orig-temp")

QE_vm_bootCutOff=$((QE_vm_bootLength-QE_qemuCallPoint+1))

#echo "QE_qemuCallPoint  $QE_qemuCallPoint  QE_vm_bootLength  $QE_vm_bootLength  QE_vm_bootCutOff  $QE_vm_bootCutOff  "

declare -f vm_boot  | head -n -"$QE_vm_bootCutOff"  >  "/tmp/qmod-function-vm_boot-temp"


## ADD-IN extra code  ( place between the first EOF line & the brace that closes the tail trimmed boot function, just before the second EOF)

# See https://stackoverflow.com/questions/22697688/how-to-cat-eof-a-file-containing-code     ( use escape EOF, not quotes )

cat << \EOF >> "/tmp/qmod-function-vm_boot-temp"

    #  REVIEW can patching in $WinHyperV_RC  & creating a RC reader function be done here ??

    # Show all the compiled qemu & swmtp arguments as a human readable list 
    # both to a log file and to screen   (Args & Args/HW record are defined after the VM selection or re-selection)

    printf   "\n  Present Working Directory:  %s"  "$(pwd)" > "$QemuArgsFile"
    printf "\n\n  Qemu:      %s  %s" "$QEMU" "$QEMU_VER_LONG" >> "$QemuArgsFile"
    printf "\n\n  QuickEmu:  %s" "$VERSION"  >> "$QemuArgsFile"
    printf "\n\n  Q wrap:    %s" "$ModVersion" >> "$QemuArgsFile"
    printf "\n\n  Date:      %s \n" "$(date)" >> "$QemuArgsFile"

    for a in "${args[@]}"; do
      if [[ "$a" == -dev* ]]; then printf "\n\n  %s" "$a" >> "$QemuArgsFile"
      elif [[ "$a" == -* ]]; then printf "\n  %s" "$a" >> "$QemuArgsFile" 
      else printf " %s" "$a" >> "$QemuArgsFile"
      fi
    done

    [[ $ExtraArgs ]] && printf "\n\n  ExtraArgs: %s "  "$ExtraArgs"  >> "$QemuArgsFile"

    if [[ $tpm == "on" ]]; then 
      printf "\n\n\n  Secure Boot:  %s \n\n  %s " "$SWTPM" "${tpm_args[*]}" >> "$QemuArgsFile"
    else    
      printf "\n\n\n  Secure Boot:  Not Set" >> "$QemuArgsFile"
    fi
      printf "\n\n\n"  >> "$QemuArgsFile"

    if [[ $VerboseArgs ]]; then 

      # hold the launch till we have checked the config 
      BreakAtVerboseArgs=
      cat "$QemuArgsFile"
      printColor "  [enter] to continue  [b] to go back \n\n"
      read -rp " >  " BreakAtVerboseArgs
      printf "\n\n"
      [[ $BreakAtVerboseArgs == "b" ]]  && return

    fi

    ##  Make sure we have a record of the virtual hardware that Qemu creates. Especially useful for Windows builds.

    #   See  https://github.com/quickemu-project/quickemu/issues/572#issuecomment-1531348755

    [[ ! -e "$QemuArgsFile" ]] && printColor "\n\n  ERROR QemuArgsFile %s failed to create \n\n"  "$QemuArgsFile" && sleep 3 && exit 1

    [[ ! -e "$QemuVirtHardwareRecord" ]]  &&  cp "$QemuArgsFile"  "$QemuVirtHardwareRecord"

    ## call QEMU  (with any extras, if present)

    # -D  https://qemu.readthedocs.io/en/latest/system/invocation.html
  
    eval "$QEMU" "${args[*]}" " $ExtraArgs"  -D  "${VMDIR}/${VMNAME}.qemu.error.log" &

    # wait $! not needed. Control now moved to PID menu instead

  fi
  
}

EOF


## Now add the modded boot code as the new function 'vm_boot'

source "/tmp/qmod-function-vm_boot-temp"


## Add in the standard parameter cases 

tail +"$QE_EOfuncsPoint" "$QuickEmuSource" > "/tmp/qmod-endof-file-temp"

# note ' case' with space or grep picks up "Lowercase" on line 3

QE_StartCasePoint=$(grep -n -m 1 ' case' "/tmp/qmod-endof-file-temp" | cut -d ':' -f 1)

QE_EoCasePoint=$(grep -n -m 1 'esac' "/tmp/qmod-endof-file-temp" | cut -d ':' -f 1)

((QE_EoCasePoint -= (QE_StartCasePoint -1) ))

tail "+$QE_StartCasePoint" "/tmp/qmod-endof-file-temp" | head -"$QE_EoCasePoint"  > "/tmp/qmod-case-temp"


##  Add in the standard actions 

((QE_EoCasePoint += (QE_StartCasePoint +2) ))

QE_vm_bootPoint=$(grep -n -m 1 'vm_boot' "/tmp/qmod-endof-file-temp" | cut -d ':' -f 1)

((QE_vm_bootPoint -= 2))

QE_EoLength=$(wc -l < "/tmp/qmod-endof-file-temp")

QE_BootRemainder=$((QE_EoLength - QE_vm_bootPoint))

tail "+$QE_EoCasePoint" "/tmp/qmod-endof-file-temp" | head -n -"$QE_BootRemainder" > "/tmp/qmod-actions-temp"

tail "+$QE_vm_bootPoint" "/tmp/qmod-endof-file-temp" | head -n -1 > "/tmp/qmod-boot-temp"



function quickemu {      

  # Any calls to quickemu become re-routed to this function instead.

  # Check 'mod' params first, then quickemu's

  # plus quickemu_vars have to be cleared before every call to quickemu as the base code is normally set to be run once & exit

  clear_quickemu_vars


  ## Do a first check for amy qwrap internal commands 

  local FirstParamCount=0

  IFS=' '  read -ra FirstParamsArray <<< "$*"

  # declare -p FirstParamsArray

  # read

  # https://unix.stackexchange.com/questions/50654/function-caller-positional-parameters?rq=1

  while [[ "${FirstParamsArray[$FirstParamCount]}" ]]; do

    for FirstParam in "${FirstParamsArray[@]}"; do

      case "$FirstParam" in
      
        --vm_boot)  
            VM_ExecBoot=1 
            unset "FirstParamsArray[$FirstParamCount]"
            set -- "${FirstParamsArray[@]}"
            # no other cases applicable, move on.
            break
            ;;
        --menu_bypass)
            # used for msr functions below
            unset "FirstParamsArray[$FirstParamCount]"
            set -- "${FirstParamsArray[@]}"          
            shift ;;
        --toggle_msr_defaults)  
            toggle_msr_defaults 
            exit directly ;; 
        --select_msr_config)  
            select_msr_config 
            exit directly ;; 
        --msrs_conflict_check_resolver)  
            msrs_conflict_check_resolver 
            exit directly ;; 
      esac

      ((FirstParamCount+=1))

    done

  done


  ## Source in original or modded-original code
  
  while [[ $1 ]]; do

    source "/tmp/qmod-case-temp"

  done  

  # after read, remove any leftover params not cleared due to trapped exit re-route 

  # & if not yet given, decide on action   

  #  https://unix.stackexchange.com/questions/18981/how-to-unset-the-positional-parameters

  shift  $#

  source "/tmp/qmod-actions-temp"


  if [[ $VM_ExecBoot ]]; then

    # In the modded version, functions such as snapshots no longer exit. We need to make sure that 
    # unless flagged to do so, quickemu doesn't carry on to run the vm boot

    source "/tmp/qmod-boot-temp"

    VM_ExecBoot=

  fi

}


# Temps get removed with time or with reboot

# See https://serverfault.com/questions/377348/when-does-tmp-get-cleared#377349



##  WRAPPING FUNCTIONS FOR 'quickget' 

#   Versioned, but INTENDED TO WORK FROM INSIDE 'quickemu-wrap'


QGW_Version="2023.05.31"


QGW_ArrList() {

  # listing function for use inside 'function_quick_get_wrap'

  declare -n QGW_List_ArrName="$1"

  QGW_List_ArrNum=0

  QGW_List_DisplayNum=1

  QGW_List_NewLineCounter=1

  for QGW_List_Arr_Item in "${QGW_List_ArrName[@]}" ; do

    printf "  %2d)  %-18s  "  "$QGW_List_DisplayNum"  "$QGW_List_Arr_Item"

    ((QGW_List_ArrNum+=1))

    ((QGW_List_DisplayNum+=1))

    ((QGW_List_NewLineCounter+=1))

    [[ $QGW_List_NewLineCounter == "6" ]] &&  QGW_List_NewLineCounter=1   &&  printf "\n\n"

  done

}


function_quick_get_wrap ()  {

  printf "\033c"

  printColor "\n\n  Quick Get Wrap Ver: %s "  "$QGW_Version"

  # shellcheck disable=SC2154

  printf "  Wrapping quickget version %s  \n\n  (selection of some distro's will require live version data) \n\n\n" "$QG_Wrapped_VerNumber"

 
  tput sc
  echo 
  echo "  Checking connections ..." ; echo

  InternetUp=
  Test_Internet=

  while [[ ! $InternetUp ]]; do   

    if  ( ping -w 2  1.1.1.1 | grep -q ttl ) 2> /dev/null ; then

      InternetUp=1

    elif wget -q -T2 -t2 --spider 1.1.1.1  2> /dev/null ; then
    
      InternetUp=1

    elif wget -q -T2 -t2 --spider cloudflare.com  2> /dev/null ; then

      InternetUp=1

    elif wget -q -T2 -t2 --spider google.com 2> /dev/null ; then

      InternetUp=1

    elif ( ping -w 2  8.8.8.8  | grep -q ttl ) 2> /dev/null ; then

      InternetUp=1    
      
    else

      printColor "\n\n  INTERNET CONNECTION NOT FOUND. Check settings and equipment \n\n"

      printf "\n\n  [enter] to re-test,  [i] ignore, continue anyway  [b] back to main menu"

      read -rp "   >  "   Test_Internet

      echo

      [[ $Test_Internet == "b" ]] &&  QGW_List_NumSelected="b"  && break   

      [[ $Test_Internet == "i" ]] &&  break   

    fi

  done


  if [[ $InternetUp ]] || [[ $Test_Internet == "i" ]]; then  

    tput rc; tput ed  

    QGW_OS_ListRaw="$(quickget | tail -n +2 )"

    QGW_OS_ListString="${QGW_OS_ListRaw/'- Operating Systems: '/}"

    read -ra QGW_OS_Array <<< "$QGW_OS_ListString"

    QGW_ArrList  "QGW_OS_Array"

    printColor "\n\n\n  Give list NUMBER of OS name to select for download  [b] to go back \n\n"    

    read -rp "  >  "  QGW_List_NumSelected

  fi

  if [[ $QGW_List_NumSelected == "b" ]]; then 
  
    QGW_List_NumSelected=

    return

  else

    [[ $QGW_List_NumSelected -gt "${#QGW_OS_Array[@]}" ]] && QGW_List_NumSelected="${#QGW_OS_Array[@]}"

    QGW_OS_Arr_NumSelected=$((QGW_List_NumSelected-1))

    QGW_OS_Arr_NameSelected="${QGW_OS_Array[QGW_OS_Arr_NumSelected]}"

    printColor  "\n\n  Selected = %s "  "$QGW_OS_Arr_NameSelected"

  fi

  #

  QGW_Releases_ListRaw="$(quickget "$QGW_OS_Arr_NameSelected" | tail -n +2 | grep Releases)"

  QGW_Releases_ListString="${QGW_Releases_ListRaw/'- Releases: '/}"

  read -ra QGW_Releases_Array <<< "$QGW_Releases_ListString"

  if [[ ${#QGW_Releases_Array[@]} -eq 1 ]] ; then

   printf "\n\n  Only one current release found: "

   QGW_Release_Arr_NameSelected="${QGW_Releases_Array[0]}"

  else

    printf "\n\n"

    QGW_ArrList  "QGW_Releases_Array"

    printColor "\n\n  Give LIST number of Release   [b] to go back \n\n"     

    read -rp "  >  "  QGW_List_NumSelected    

    if [[ $QGW_List_NumSelected == "b" ]]; then 

      QGW_List_NumSelected= 

      QGW_OS_Arr_NameSelected=
    
      function_quick_get_wrap

    else

      [[ $QGW_List_NumSelected -gt "${#QGW_Releases_Array[@]}" ]] && QGW_List_NumSelected="${#QGW_Releases_Array[@]}"

      QGW_Release_Arr_NumSelected=$((QGW_List_NumSelected-1))

      QGW_Release_Arr_NameSelected="${QGW_Releases_Array[QGW_Release_Arr_NumSelected]}"

    fi

  fi

  printColor  "\n\n  Selected = %s %s "  "$QGW_OS_Arr_NameSelected" "$QGW_Release_Arr_NameSelected"

  #

  QGW_Editions_ListRaw="$(quickget "$QGW_OS_Arr_NameSelected" | tail -n +2 | grep Editions)"

  QGW_Editions_ListString="${QGW_Editions_ListRaw/'- Editions: '/}"

  QGW_Editions_ListTest="$(tr -d '[:space:]' <<< "$QGW_Editions_ListString" )"

  if [[ $QGW_Editions_ListTest ]]; then

    read -ra QGW_Editions_Array <<< "$QGW_Editions_ListString"

    if [[ ${#QGW_Editions_Array[@]} -eq 1 ]] ; then

    printf "\n\n  Only one current edition found: "

    QGW_Edition_Arr_NameSelected="${QGW_Editions_Array[0]}"

    else

      printf "\n\n"

      QGW_ArrList  "QGW_Editions_Array"

      printColor "\n\n  Give LIST number of Edition   [b] to go back \n\n"  

      if [[ $QGW_OS_Arr_NameSelected == "fedora" ]]  && [[ $QGW_Release_Arr_NameSelected == "33" ]] || [[ $QGW_Release_Arr_NameSelected == "34" ]]; then 
      
        printf "  Note: Fedora 33 i3 and Fedora 34 Cinnamon are not possible \n\n"

      fi

      read -rp "  >  "  QGW_List_NumSelected   

      if [[ $QGW_List_NumSelected == "b" ]]; then  

        QGW_List_NumSelected=
        QGW_OS_Arr_NameSelected=
        QGW_Release_Arr_NameSelected=
      
        function_quick_get_wrap

      else

        [[ $QGW_List_NumSelected -gt "${#QGW_Editions_Array[@]}" ]] && QGW_List_NumSelected="${#QGW_Editions_Array[@]}"
    
        QGW_Edition_Arr_NumSelected=$((QGW_List_NumSelected-1))

        QGW_Edition_Arr_NameSelected="${QGW_Editions_Array[QGW_Edition_Arr_NumSelected]}"

      fi

    fi

  else

    QGW_Edition_Arr_NameSelected=

    printf "\n\n  Further selection not available"

  fi


  QGW_DownloadSelection="$QGW_OS_Arr_NameSelected  $QGW_Release_Arr_NameSelected  $QGW_Edition_Arr_NameSelected"
  
  printColor  "\n\n  Selected =   %s "  "$QGW_DownloadSelection"

  i=0

  while [[ ${VM_Folder_List[i]} ]]; do

    if [[ $i -eq 0 ]]; then printf "\n\n\n  [0]  %s (current)"  "${VM_Folder_List[i]}"

    elif [[ $i -eq 1 ]]; then printf "\n\n  [1]  %s (default)"  "${VM_Folder_List[i]}"

    else printf "\n\n  [%s]  %s "  "$i" "${VM_Folder_List[i]}"

    fi

    ((i +=1))

  done

  printf "\n\n\n"

  QWG_DownLoadFolder="$Default_VM_Folder"
  
  while true ; do

    printf "  Installation target folder:  %s "   "$QWG_DownLoadFolder"  

    printColor  "\n\n  [enter] Start the download  [number] select a different (preset or current) folder  [h] help  [b] go back \n\n"

    read -rp "  >  " QGW_DownloadStart

     printf "\n"

     case "$QGW_DownloadStart" in

      b)
        QGW_List_NumSelected=
        QGW_OS_Arr_NameSelected=
        QGW_Release_Arr_NameSelected=
        QGW_DownloadStart=
        QGW_DownloadSelection=

        function_quick_get_wrap

        break
      ;;


      0|1|2|3) QWG_DownLoadFolder="${VM_Folder_List[QGW_DownloadStart]}" 
      
      ;;

      h)  
          printf "\n\n  Once the download and initial setup up has finished, the new folder and .conf file may be easily moved"
          printf "\n\n  and/or edited before running. Part downloads can usually be re-started, if stopped."

      ;;

      *)
        QGW_DownloadStart="start"
        break
      ;;

    esac

    [[ ! $QWG_DownLoadFolder ]] &&  QWG_DownLoadFolder="$Default_VM_Folder" 

  done


  if [[ $QGW_DownloadStart == "start" ]]; then

    QGW_DownloadStart=
    QGW_DownloadStopped=
    
    cd "$QWG_DownLoadFolder"  ||  function_conf_error  "FOLDER not accessible: $QWG_DownLoadFolder"

    
    printf "\n  Once a download and initial setup up has finished, the new folder and .conf file may be easily moved"
    printf "\n\n  and/or edited before running. Part downloads can usually be re-started, if stopped."
    
    printf "  %s \n\n" "$QGW_DownloadSelection"

    printColor "\n\n  [enter] to finish ALL current downloads "

    printf "\n\n  Quickemu & downloader output: "


    ## Although quickget will run as a background process, quickget will then go on to run aria2 etc 

    #  but as even further into the background. The download programs will grab the cursor in order to report progress
    
    #  and as this will compete with read & keyboard input we are limited to using [enter] ....


    # quickget runs first, then it starts a downloader 


    quickget "$QGW_DownloadSelection" &  

    printf "\n\n\n\n\n"

    #  move the cursor   "\e[1A\r"  "\e[2K\r"  etc    See https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797

    printf "\e[3A\r"

    sleep 2
   
    while true ; do

      read -r 

      if [[ $(pgrep aria2) || $(pgrep curl) || $(pgrep wget) ]]; then

        pkill aria2
        pkill curl
        pkill wget 
        pkill quickemu 

        QGW_DownloadStopped=1

        sleep 2 ; break

      elif [[ "$(jobs -l)" == 'quickget'* ]]; then
      
        sleep 1; break

      else 
      
        break

      fi

    done

  fi

  # variable sleep/pauses needed to give different processes time to output their summaries & finish up

  sleep 1


  New_VM_Folder=
 
  if [[ -d "${QWG_DownLoadFolder}/${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}-${QGW_Edition_Arr_NameSelected}" ]]; then 

    New_VM_Folder="${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}-${QGW_Edition_Arr_NameSelected}"

  elif [[ -d "${QWG_DownLoadFolder}/${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}" ]]; then 

    New_VM_Folder="${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}"

  elif [[ -d "${QWG_DownLoadFolder}/${QGW_OS_Arr_NameSelected}" ]]; then 

    New_VM_Folder="${QGW_OS_Arr_NameSelected}"

  fi


   New_VM_File=

  if [[ -f "${QWG_DownLoadFolder}/${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}.conf" ]]; then 

    New_VM_File="${QWG_DownLoadFolder}/${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}.conf"

  elif [[ -f "${QWG_DownLoadFolder}/${QGW_OS_Arr_NameSelected}.conf" ]]; then 

    New_VM_File="${QGW_OS_Arr_NameSelected}.conf"

  fi


  QGW_FolderDelete=

  if [[ $New_VM_Folder ]]; then
  
    printColor "\n  Folder created:  %s "  "$New_VM_Folder"

    if [[ ! $New_VM_File ]]; then

      if [[ $QGW_DownloadStopped ]]; then 
      
        printf "\n\n  Download Stopped > Residual files are present"

        printf "\n\n  Part downloads can usually be re-started if the folder is retained."

      else  
      
        printf "\n\n  As there is no .conf file, there may have been an ERROR >" 
        
      fi

      printColor "\n\n  Folder contents: \n\n"

      ls "$New_VM_Folder"

      printColor "\n  [d] delete the folder" 

      printf "  [enter] to retain & continue "

      printf "\n\n"

      read -rp "  >  "    QGW_FolderDelete

      if [[ $QGW_FolderDelete == "d" ]]; then
      
        printf "\n\n  Folder being deleted ... \n\n"

        rm -f -r "$New_VM_Folder"

      else  printColor  "  Folder retained"

      fi

    fi

  fi


  QGW_ConfEdit=

  if [[ $New_VM_File ]]; then

    printColor "\n\n  Config file created"

    printColor "  CHECK ME, NOW: \n\n"

    cat "$New_VM_File"

    printColor "\n\n  So far, so good  >  "

    printf "\n\n  The start line may be edited to point to %s"  "$ModName"

    printf "\n\n  Suggest disk_size=\"32G\" or higher if expecting to create snapshots. Note that" 

    printf "\n\n  qcow2 disks auto-compress & will normally occupy much less of your hard drive "
    
    printf "\n\n  than that allocated. It is easier make them larger now than to resize later." 

    if [[ $QGW_OS_Arr_NameSelected =~ "windows" ]]; then
    
      printColor "\n\n  Windows: needs tpm=\"on\" secureboot=\"on\""

      printf "\n\n  Set disk_size=\"128G\" (recommended)"
      printf "\n\n  plus set other vals high eg cpu_cores=\"12\" ram=\"10G\" "

    fi

    printColor "\n\n\n  [enter] edit the config file   [c] continue (with current settings)  [d]  delete - something went wrong ..."

    printf "\n\n"

    read -rp "  >  "   QGW_ConfEdit

  
    if [[ $QGW_ConfEdit == "c" ]]; then 

      true
    
    elif [[ $QGW_ConfEdit == "d" ]]; then 
    
      function_delete_Selected_VM  "$New_VM_Folder" "$New_VM_File"

    else 
    
      qmod_edit_settings  "new_conf"

    fi


  elif [[ $QGW_FolderDelete == "d" ]]; then

    sleep 1.4

  else

    printColor "\n\n  [enter] to return or continue \n\n" 
    read -rp "  > "

  fi

  
  # return back to any working directory if one had already been set  ( REVIEW is this right in all cases?)

  if [[ $VM_Conf_Dir ]]; then cd "$VM_Conf_Dir"  || function_conf_error  "Quickget-Wrap Working Directory NOT FOUND ," ; fi


  function_refresh_and_reload_VM_arrays

  ByPass_VM_Array_Selector=1

}




##  END of ADD-IN of ORIGINAL QUICKEMU and setting up the QUICKGET wrapper.  START MENU FUNCTIONS:



function_conf_error () {

  ErrorMenuSelect=

  NewSetupFlag=

  printf "\n\n  Quickemu-Wrap Settings, VM folder & conf file(s)"

  if [[ $1 ]] ; then printf "\n\n  Check %s settings, location & content ... "  "$1"

  else printf "\n\n  Check the settings and re-run this script ... " ; fi


  printf "\n\n  Settings file:  %s \n\n" "$Q_Mod_SettingsFile"

  
  if [[ "$1" == *'COMMAND'* ]]; then 
  
    printColor "\n\n  [q] to quit "

    printf "  [enter] to view/edit settings file \n\n"

  elif [[ $1 == "folder" ]] && [[ $(ls "$VM_InstanceName"/*.iso 2> /dev/null) ]]; then 

    printColor "\n  CHECK ME, NOW: \n\n"

    cat "$VM_Conf_File"

    NewSetupFlag=1
     
    printColor "\n\n  NEW SETUP:  [enter]  edit the .conf file   [c] continue  (with current settings) "

    if [[ "$VM_InstanceName" =~ 'windows' ]]; then 
    
      printf "\n\n  128G disk size edit recommended, plus make sure tpm and secure boot are on"

      printf "\n\n  Use: fixed_iso=\"windows-xx/virtio-win-0.1.225.iso\" for display drivers & guest additions "

    fi

    printf "\\n\n  [e] to edit %s general settings   [q] to quit \n\n"   "$ModName"
    
  else   
  
    printColor "\n\n  [Enter] to edit %s settings"  "$ModName" 

    [[ "$1" == *'No VMs'* ]] && printColor "  [gt] quickget a new distro "

    printColor "  [q] to quit \n\n"  

  fi   

  read -rp "  >  "   ErrorMenuSelect

  [[ $ErrorMenuSelect == "q" ]] && printf "\n\n" && command exit 

  if [[ $ErrorMenuSelect == "c" ]] || [[ $ErrorMenuSelect == "e" ]] || [[ $ErrorMenuSelect == "gt" ]]; then  
  
    SelectArrayError=
    IgnoreFolderCheck=1

    if [[ $ErrorMenuSelect == "e" ]]; then 

      if [[ $NewSetupFlag ]]; then qmod_edit_settings ; else qmod_edit_settings  "conf" ; fi

    elif [[ $ErrorMenuSelect == "gt" ]]; then 

      VM_Selection=
      function_quick_get_wrap 
      return

    fi
  
  else  
  
    if [[ $NewSetupFlag ]]; then 

      NewSetupFlag=

      printf "\n\n  To auto-run  quickemu-wrap / qwrap :"

      printf "\n\n  #!/usr/bin/quickemu --vm   becomes   #!/usr/bin/quickemu-wrap --vm   #!/usr/bin/qwrap --vm   or similar "

      [[ $ModName_qqX ]] && printf "\n\n  Adjust to read as qqx (or qqX) instead od quickemu "

      printColor "\n\n  [enter] to continue \n\n"

      read -rp "  >  "
    
      qmod_edit_settings  "conf" 
      
    else 
    
      qmod_edit_settings
    
    fi
    
  fi

}


function_VM_array_add_confs () {

  ## Adds to VM array & lists, if submitted item has not been already listed 

  # where $1 is 'VM_Path' and  $2 is 'VM_Conf' to be tested against the existing list (non-sparse)

  #  If initial settings file has populated / part-populated the array then ${VM_Array[0,0]} will be present

  if [[ $1 ]]; then

    # make sure that a $1 has been sent & that the calling array splitter hasn't sent an empty value

    TestFolderFile="$1/$2"

    [[ ! -e $TestFolderFile ]] && function_conf_error  "VM_array_add_confs: File Not Found" && return 
    

    if [[ ! ${VM_Array[0,0]} ]]; then 
    
      New_VM_Number=0  

    else 
    
      New_VM_Number="$((${#VM_Array[@]} / 2))" 

      local i=0

      while [[ ${VM_Array[$i,0]} ]]; do

        ArrFolderFile="${VM_Array[$i,0]}/${VM_Array[$i,1]}"

        if [[ $ArrFolderFile == "$TestFolderFile" ]]; then 
        
          # already exists, stop searching, quit function:
          return

        else  

          # carry on interating the array
          ((i+=1))  

        fi
        
      done

    fi

    if grep -q 'guest_os=' "$TestFolderFile" 2> /dev/null ; then

      # if at the end there is no match found, then add it, if it is valid

      VM_Array[$New_VM_Number,0]="$1" 
      VM_Array[$New_VM_Number,1]="$2" 

    fi

  fi
  
}


function_scan_VM_folderList () {

  ##  Scans of current & listed VM folders for other potential '.conf' files to the VM array

  #   Adds via calls to 'function_VM_array_add_confs'

  i=0

  while [[ ${VM_Folder_List[i]} ]]; do

    FolderPathName="${VM_Folder_List[i]}"

    Folder_Conf_String="$(ls "$FolderPathName/"*.conf 2> /dev/null)"

    Folder_Conf_String=${Folder_Conf_String//"$FolderPathName/"/}

    mapfile -t  Folder_Conf_Array  <<< "$Folder_Conf_String"

    if [[ ${Folder_Conf_Array[0]} ]]; then 

      for TestFile in "${Folder_Conf_Array[@]}"; do 
           
      [[ $TestFile ]] && function_VM_array_add_confs  "$FolderPathName" "$TestFile" 
      
      done

    fi

    ((i +=1))

  done
  

  if [[ ! ${VM_Array[0,0]} ]] ; then
    function_conf_error  "VM ARRAY - No VMs found?"
    SelectArrayError=1
  fi

}



function_print_conf_array () {

  # Print a list of the VM's in the VM array

  VM_List_Num=0

  while [[ ${VM_Array[$VM_List_Num,0]} ]] ; do

    if [[ ! -d "${VM_Array[$VM_List_Num,0]}" ]]; then 

      printf "\n\n  ERROR  %s folder not found: \n\n  %s \n\n" "$ModName" "${VM_Array[$VM_List_Num,0]}"   

      function_conf_error  "folder $VM_List_Num" 
      SelectArrayError=1
      break 

    else

      if [[ -e "${VM_Array[$VM_List_Num,0]}/${VM_Array[$VM_List_Num,1]}" ]]; then 

        if [[ ! $ByPass_VM_Array_Selector ]]; then

          QcowTarget=

          QcowTarget="$(grep 'disk_img' "${VM_Array[$VM_List_Num,0]}/${VM_Array[$VM_List_Num,1]}" 2> /dev/null)"

          QcowTarget="${QcowTarget/'disk_img='/}"

          QcowTarget="${QcowTarget//'"'/}"

          if [[ ! -e "${VM_Array[$VM_List_Num,0]}/$QcowTarget" ]]; then  
            printColor "\n\n %2d  %s  (new)" "$VM_List_Num" "${VM_Array[$VM_List_Num,0]}/${VM_Array[$VM_List_Num,1]}"
          else
            printf "\n\n %2d  %s " "$VM_List_Num" "${VM_Array[$VM_List_Num,0]}/${VM_Array[$VM_List_Num,1]}"
          fi
        fi

      else

        printf "\n\n  ERROR  %s ' .conf ' not found: \n\n  %s \n\n" "$ModName" "${VM_Array[$VM_List_Num,0]}/${VM_Array[$VM_List_Num,1]}"

        function_conf_error  "config $VM_List_Num" 
        SelectArrayError=1
        break

      fi

    fi

    ((VM_List_Num+=1))

  done
  
}


function_Select_VM () {  

  SelectArrayError=

   
  if [[ $ByPass_VM_Array_Loader ]] && [[ ${VM_Array[0,0]} ]]; then

    # if reselecting & the array is already loaded (which it should be ...)

    # printf "\n\n  ByPassing VM Loader ... "  

    ByPass_VM_Array_Loader=

  else 

    # Re-scan folders as something new may have been added

    function_scan_VM_folderList

    function_VM_array_add_confs

  fi


  if [[ $ByPass_VM_Array_Selector ]] || [[ $SelectArrayError ]] ; then

    # printf "\n\n  ByPassing VM Selector ... "

    true

  else 

    VM_Selection=
    VM_Conf_Dir=
    VM_Conf_File=

    function_print_conf_array

    
    if [[ $DefaultFolderError || $ExtraFolderError ]]; then 

    printf "\n\n\n  Settings file: %s" "$Q_Mod_SettingsFile"

    [[ $DefaultFolderError ]] && printf "\n\n  ERROR: DEFAULT FOLDER   [enter] to edit settings file  [q] to quit " 

    [[ $ExtraFolderError ]] && printf "\n\n  ERROR: EXTRA FOLDER   [enter] to edit settings file  [q] to quit "

    else

      printf "\n\n\n  [number] to select a VM   [gt] quickget a new distro   [q] to quit "

      printColor "\n\n  [Enter]  to select %s (VM 0)"  "${VM_Array[0,1]}"

    fi

    printf "\n\n"

    read -rp  "   >  "  VM_Selection



    [[ $VM_Selection == "q" ]] && echo && exit directly 

    if [[ $DefaultFolderError || $ExtraFolderError ]]; then 
          
      DefaultFolderError= 
      ExtraFolderError=
      VM_Selection=
      VM_InstanceName=
      qmod_edit_settings 
      return

    fi



    if [[ $VM_Selection == "gt" ]]; then

      VM_Selection=
      function_quick_get_wrap 

      ByPass_VM_Array_Loader=

      printf "\033c"
      show_qmod_title
      return

    fi

    [[ ! $VM_Selection ]] &&  VM_Selection=0  

    printf "\n\n  Selecting instance %s \n\n"  "$VM_Selection"

    VM_Conf_Dir="${VM_Array[$VM_Selection,0]}"
    VM_Conf_File="${VM_Array[$VM_Selection,1]}"

  fi


  if [[ $SettingsFileAdjusted && $ByPass_VM_Array_Selector ]] || [[ $SelectArrayError ]]; then

    # Only the array checker is run after a settings edit, if a VM selection is already in place 

    # printf "\n\n  Maintaining current KVM settings ... "

    true

  else

    ## Check file/folder exists

    [[ ! -d "$VM_Conf_Dir" ]] &&  function_conf_error  "folder"  && SelectArrayError=1


    ## CHANGE DIRECTORY to where the VM is

    ! cd "$VM_Conf_Dir"  &&  printColor "\n\n  ERROR  .conf  folder switching \n\n" && sleep 5 && exit 1


    [[ ! -e "$VM_Conf_File" ]] &&  function_conf_error  ".conf file" && SelectArrayError=1


    # Set Instance Name, following Quickemu pattern which sets the same name to the .conf file and to the main folder 

    VM_InstanceName="${VM_Conf_File/.conf}"


    # Check that the dir contains the right files  &&  grep .conf for right content

    if [[ $IgnoreFolderCheck ]]; then

      IgnoreFolderCheck=

    else

      [[ ! $(ls "$VM_InstanceName"/*.qcow2 2> /dev/null) ]] && function_conf_error  "folder"  && SelectArrayError=1

    fi

    ! grep -q 'guest_os=' "$VM_Conf_File" 2> /dev/null && function_conf_error  ".conf file"   && SelectArrayError=1
  

    # Check KVM parameter settings & advise according to guest OS

    KVM_MSR_selector=

    function_find_kvm_msr_default_and_status

    if [[ $Verbose_MSR_dialog ]] || [[ ! $Verbose_MSR_dialog ]] && [[ "$VM_InstanceName" == *windows* || "$VM_InstanceName" == *macos* ]]; then 
    
      msrs_conflict_check_resolver

    fi

  fi

  # clear any no-longer needed flags

  Select_VM=

  ByPass_VM_Array_Loader=
  ByPass_VM_Array_Selector=

  # reload if the editor was called, due to settings error

  if [[ $SelectArrayError ]]; then
  
    MainMenuChoice="refresh" 
    Select_VM=1

    [[ $VM_InstanceName ]] && ByPass_VM_Array_Selector=1

  else

    SettingsFileAdjusted=

  fi

}



KDE_ctrl_c_msg () {

  # KDE/konsole    See: https://bugs.kde.org/show_bug.cgi?id=313862

  # REVIEW remove? has ctrl-c been coded-out now?  Here mainly as a quick fix solution ...

  if [[ $XDG_SESSION_DESKTOP == "KDE" ]] || [[ $XDG_CURRENT_DESKTOP == "KDE" ]]; then   printf " - [ctrl-shift-q] to quit" 

  else printf " - [ctrl-c] to quit"  ; fi

}


function_snapshot_list() {

  printf "\n\n"

	quickemu --vm "$VM_Conf_File" --snapshot info

}


function_KillPID_Menu() {

  tput civis

	# WAIT for background load & QEMU messages to appear before showing menu (unless reloading)

	if [[ $KillPID_Menu_Exited ]]; then  KillPID_Menu_Exited=

  elif [[ $BreakAtVerboseArgs ]]; then BreakAtVerboseArgs= ; return

  else  sleep 2 ; fi
  
  #if [[ ! $InstancePID ]]; then

    # belt & braces check for the PID:  

    #InstancePID="$(pgrep "$VM_InstanceName")"

    #echo "PID $InstancePID - VM_InstanceName $VM_InstanceName "


    # braces: qemu SHOULD write a .pid file while it is running & remove it when not  
    
    # REVIEW  Probably we should assume VM is not running if QEMU's & file is not there as this would indicate QEMU failure

    # [[ ! $InstancePID ]] && InstancePID="$(cat "${VMDIR}/${VMNAME}.pid")"

    InstancePID="$(cat "${VMDIR}/${VMNAME}.pid" 2> /dev/null)"

    # echo "PID $InstancePID - VMDIR $VMDIR  VMNAME  $VMNAME QEMU $QEMU"

  #fi

  if [[ $InstancePID ]]; then 
 
    sleep 40   # REVIEW  can message output be better monitored?

    printColor "\n  Quickemu instance %s on PID:  %s"  "$VM_InstanceName"  "$InstancePID"

    printColor  "   [k] force close the Quickemu instance  \n\n"

  fi

  # return to menu requires VM to be shutdown first

  while true ; do 

    read -rp  "  >  " -t 1  KillPID_Menu

    if [[ $KillPID_Menu == "k" ]]; then 

      printf "\n\n"
      [[ $( ps -p "$InstancePID" --no-headers ) ]] &&  kill "$InstancePID" &
      sleep 3
      printf "\n\n"

      tput cnorm
      break

    else

      if [[ ! $( ps -p "$InstancePID" --no-headers ) ]]; then 
      
        tput cnorm 
        break 

      else

        #  Erase text and adjust cursor:   "\e[1A\r"  "\e[2K\r"  etc    See https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797
       
        printf "\r"

      fi

    fi

  done

  KillPID_Menu=

  KillPID_Menu_Exited=1

}	

qmod_edit_settings() {

  if [[ ! $TextEditor ]]; then
  
    DefaultTextEditor="$(xdg-mime query default text/plain)"

    EditorTest="${DefaultTextEditor/\/.desktop//}"

    EditorTest="$(tr -cd "[:alnum:]" <<< "$EditorTest")"

    if [[ $DefaultTextEditor ]] && [[ $(type -p "$EditorTest") ]] ; then

      TextEditor="${DefaultTextEditor/.desktop/}"

    elif [[ $(type -p gedit) ]] ; then 

      TextEditor="gedit"

    elif [[ $(type -p pluma) ]] ; then 

      TextEditor="pluma"

    elif [[ $(type -p kate) ]] ; then 

      TextEditor="kate"

    elif [[ $(type -p nano) ]] ; then 

      TextEditor="nano"

    fi

  fi

  if [[ $(type -p "$TextEditor") ]]; then 

    # Run the editor: 

    # Note, can throw a complaint if 'xapps' has not not been installed, but works ...  YMMV  (2> /dev/null)

    # https://askubuntu.com/questions/1396739/failed-to-load-module-xapp-gtk3-module

    if [[ $1 == "conf" ]]; then

      "$TextEditor" "$VM_Conf_Dir/$VM_Conf_File"  2> /dev/null 

    elif [[ $1 == "new_conf" ]]; then

      "$TextEditor" "$New_VM_File"  2> /dev/null 

    else 

      "$TextEditor" "$Q_Mod_SettingsFile"  2> /dev/null 

      function_refresh_and_reload_VM_arrays
     
    fi

  else

    printColor "\n\n  Unable to find a default or basic text editor \n\n "

    printf "\n\n  Try an install of 'nano' or give settings file the command name of a preferred editor ..  "

    printf "\n\n  Settings location:  %s  \n\n"  "$Q_Mod_SettingsFile"

    read -rp "  [enter] to return >  "

  fi

}


function_delete_Selected_VM () {

  if [[ ! $1 && $2 ]]; then

    # Normally: VM_InstanceName="${VM_Conf_File/.conf}"

    printColor "\n\n  Params VM Name & VM config file (NO PATH) must be given \n\n " 

    sleep 2 ;  return

  else

    if [[ ! -d "$1" ]] || [[ ! -e "$2" ]]; then

      printColor "\n\n  Params VM Name & VM config file (NO PATH) must be given \n\n " 

      printColor "\n\n  Params VM Name / VM config file  NOT FOUND  \n\n " 

      sleep 2 ;  return

    fi

    if [[ $(type -p gio 2>/dev/null) ]]; then TrashingAvailable=1 ; else TrashingAvailable= ; fi

    printColor "\n\n  Folder: %s " "$1"
  
    printColor " & %s to be deleted?"  "$2"

    printf "\n\n Folder content: \n\n "

    ls "$1"

    if [[ $TrashingAvailable ]]; then 

      printColor "\n\n  [enter] safely move things to the trash bin"  
      
      printf "\n\n  [n] keep   [y] yes, PERMANENTLY, I have back-ups ..."

    else

      printColor "\n\n  [enter] use the file manager to move things the trash bin "
      
      printf "\n\n  [y] yes, PERMANENTLY, I have back-ups ..."

    fi

    printf "\n\n"

    read -rp "  >  "   Delete_VM_Option

    if [[ $Delete_VM_Option == "y" ]]; then 

      printf "\n\n  Folder & .conf file being deleted ... \n\n"
      
      rm -f -r "$1"  
      echo

      rm -f "$2"
      echo

    else

      # https://specifications.freedesktop.org/trash-spec/trashspec-latest.html

      if [[ $TrashingAvailable ]] && [[ $Delete_VM_Option != "n" ]]; then

        gio trash "$1"
        gio trash "$2"

      else

        printf "\n\n  NOT deleted ... \n\n"

      fi

    fi

    sleep 1.4

    printColor "\n\n  [enter] to return or continue \n\n" 
    read -rp "  > "

    function_refresh_and_reload_VM_arrays

  fi

}



function show_quickemu_WRAP_help {

  HelpSelect=

  if [[ $ModName_qqX ]]; then 
  
    echo; function_qqX_logo_title  "$qqX_title"

    printf "\n\n  %s is currently wrapping:  quickemu %s  &  quickget %s"  "$ModName" "$VERSION"  "$QG_Wrapped_VerNumber"

  else 
  
    printColor "\n\n  Quickemu Mod - Virtual Machine Launcher - Wrap Version %s %s " "$ModName" "$ModVersion" 

  fi

  printf "\n\n  For code contributions, bugs and updates, see: https://github.com/TuxVinyards"  

  printf "\n\n  Also:  https://en.wikipedia.org/wiki/Wrapper_library   https://en.wikipedia.org/wiki/Adapter_pattern"  

  printf "\n\n\n  For interactive menus, start in a folder terminal:  ./%s   or by mouse click"  "$ModName"
  
  printf "\n\n  [enter] to return   [a] qmod API detail   [p] parameters for VM runtime settings \n\n"

  read -rp "  >  "  HelpSelect

  if [[ $HelpSelect == "a" ]]; then   
  
    show_mod_api_usage  

    printf "\n\n\n"
  
    read -rp  "  [enter] to return >  " 

  elif [[ $HelpSelect == "p" ]]; then
  
    printf "\n\n  Extra quickemu parameters for qmod API & qmod settings."  
  
    printf "\n\n  NB  not all options can be applicable  CAUTION \n\n" 

    NoExit=1
    echo
    usage | tail +6
    echo

    read -rp  "  [enter] to return >  " 

  fi
}

show_qmod_title() {

  if [[ $ModName_qqX ]]; then echo ; function_qqX_logo_title  "$qqX_title"

  else printColor "\n\n  Quickemu Mod - Virtual Machine Launcher  Wrap Version %s"  "$ModVersion" ; fi

  printf "\n\n  Currently wrapping:   quickemu %s  &  quickget %s"  "$VERSION"  "$QG_Wrapped_VerNumber"

  [[ $VerboseArgs ]] && printf  "  (Verbose Args)"
  
  #printf "\n"   

  printf "\n\n  Current Folder: %s \n"  "$(pwd)"

}


function_show_main_menu_header () {

  if [[ ! $VM_InstanceName ]]; then

    Select_VM=1

  else

    #[[ $InstancePID ]] && [[ ! $( ps -p "$InstancePID" --no-headers ) ]] && InstancePID=

    [[ $InstancePID ]] && [[ ! $(cat "${VMDIR}/${VMNAME}.pid" 2> /dev/null) ]] && InstancePID=

    #  Now using Qemu's PID file.  REVIEW   

    [[ ! $InstancePID ]] && printf "\033c"  && show_qmod_title
 
    printf "\n"

    printColor "    %s " "$VM_InstanceName" 

    #  Default_VM_Folder, as defined in settings.  Highlight if using non-default or current (pwd).

    if [[ "$(pwd)" == "$Default_VM_Folder" ]]; then printf "  @   %s"  "$VM_Conf_Dir"     

    else  printColor "  @   %s"  "$VM_Conf_Dir" 

    fi

    printf "\n"

    [[ $KVM_MSR_Error ]] && print_kvm_status

  fi

}



##  START:  QUICKEMU-WRAP  menu interface  &  API DIVIDER  ###



if [[ $1 ]]; then

  # simple API for eg .desktop or .conf starts  ie.  --vm  "path/folder/file.conf"   

  if [[ $1 == "XDG" ]]; then 

    # .desktop start  (belt & braces)

    cd "$HOME"  || printf "\n\n XDG .desktop > HOME Folder not found " 

    if [[ $(pwd) != "$HOME" ]]; then

      printf "\n\n XDG .desktop > HOME Folder not found "
      sleep 3
      exit 1

    else

      CurrentFolder="$(pwd)"
      shift

    fi

  elif [[ "$1" != ?'-vm' ]]; then  
  
    show_mod_api_usage ; exit

  else 
  
    VM_Conf_Dir="$(dirname "$2")"

    VM_Conf_File="$(basename "$2")"

    shift $#
    
  fi


  if [[ ! $VM_Conf_Dir ]]; then 
  
    VM_Conf_Dir="$CurrentFolder"

  else

    if [[ ! -e  "$VM_Conf_Dir"  ]]; then 

      printColor "\n\n  %s  not found "  "$VM_Conf_Dir "
    
      function_conf_error  "Q-wrap COMMAND LINE Path Instruction,"

    else

      cd "$VM_Conf_Dir"  || function_conf_error  "Q-wrap COMMAND LINE Path Instruction,"

    fi

  fi

  if [[ ! -e "$VM_Conf_Dir/$VM_Conf_File" ]]; then 

    printColor "\n\n  %s  not found "  "$VM_Conf_File"
  
    function_conf_error  "Q-wrap COMMAND LINE .Conf Instruction,"

  fi


  # Selection now made, but array must still be loaded as may be needed for reselecting later ...

  ByPass_VM_Array_Selector=1

fi


##  Start Q-wrap menu :   

tput civis

printf "\033c"

show_qmod_title

MultiInstanceCount="$(pgrep -c "$ModName")"

if [[ $MultiInstanceCount -gt 1 ]]; then 

  printColor "\n\n  ERROR more than one instance of %s is running \n\n"  "$ModName"

  read -rp "  Close the other instances, then press [enter] to continue  > "

fi



# MAIN MENU  (select VM then choose actions to do)

while true ; do

  MainMenuChoice=

  SnapTitle=

  SnapNumber=

  SnapName=

  function_show_main_menu_header

  if [[ $SettingsFileAdjusted ]]; then 

    function_Select_VM

    MainMenuChoice="vm" 


  elif [[ $KillPID_Menu_Exited ]] || [[ $Select_VM ]] ; then

    if [[ $InstancePID ]] && [[ $( ps -p "$InstancePID" --no-headers ) ]] && [[ $(cat "${VMDIR}/${VMNAME}.pid" 2> /dev/null) ]]; then 

      #  REVIEW  add use of PID file
    
      printf "\n\n  %s is still running ..." "$VM_InstanceName"

      function_KillPID_Menu

      continue

    else 

      InstancePID=
    
      if [[ $Select_VM ]]; then  

        #declare -p VM_Array
        #echo    "  main menu loop - after Select_VM call:"
        #read -p "  VM_InstanceName is $VM_InstanceName  ByPass_VM_Array_Loader is $ByPass_VM_Array_Loader  ByPass_VM_Array_Selector is $ByPass_VM_Array_Selector"
        #echo

        function_Select_VM

        MainMenuChoice="refresh" 

                #declare -p VM_Array
        #echo    "  main menu loop - after Select_VM run:"
        #read -p "  VM_InstanceName is $VM_InstanceName  ByPass_VM_Array_Loader is $ByPass_VM_Array_Loader  ByPass_VM_Array_Selector is $ByPass_VM_Array_Selector"
        #echo

      else

        printf "\n\n    %s is now shut down" "$VM_InstanceName" 

      fi
    
    fi

    [[ $KillPID_Menu_Exited ]] && KillPID_Menu_Exited=

  fi


  ##  Set or adjust any VM_Conf_Dir related globals  (VM is now selected OR has been re-selected)

  QemuArgsFile="$VM_Conf_Dir/$VM_InstanceName/QemuArgsList.txt"

  QemuVirtHardwareRecord="$VM_Conf_Dir/$VM_InstanceName/QemuVirtHardwareRecord.txt"


  ## Print menu:

  if [[ ! $MainMenuChoice ]]; then

    printf  "\n\n"

    [[ $KVM_MSR_Error ]] && [[ ! $ShowUtilsMenu ]] && printf  "  [m]  msrs help "

    printf  "  [vm]  reselect "

    
    if [[ $ShowUtilsMenu ]]; then

      printf "   [del] delete selected VM"

      printColor  "    [u]   hide utils & technical"

      printf "\n"

      if [[ $Q_Mod_SettingsFile ]] ; then echo; echo "  Using settings file $Q_Mod_SettingsFile" ;  fi

      if [[ $VerboseArgs ]]; then printf  "\n\n  [v]   hide verbose qemu args"	

      else  printf  "\n\n  [v]   show verbose qemu args & check before booting"	
      
      fi

      printf  "\n\n  [xa]  add extra qemu args   [m] msrs help "
    
      printf "\n\n  [hdw]  Add current config to this VM's Virtual Hardware Record"
    
      [[ $ExtraArgs ]] && printf  "\n\n  Extra Args:  %s"  "$ExtraArgs"

      printf "\n"

    else

      printf  "  [u]  show utils & technical"

    fi

    printf  "\n\n  [sl]  list   [sc]  create   [sd]  delete   [sa]  apply   >  snapshots "

    printf "\n"

    printColor  "\n\n  [d]   start with default sdl display"
    
    [[ "$VM_InstanceName" =~ 'windows' ]] && printf " (useful for windows updates)"

    printColor 	"\n\n  [s]   start with spice display (scaleable) "  


    printf "\n"

    printf  "\n\n  [gt]  quickget a new distro"
    
    printf  "\n\n  [h]   show help & info   [set] open settings file in text editor "

    printf  "\n\n  [q]   quit "

    printf  "\n\n\n"


    read -rp "  >  "  MainMenuChoice

  fi


  # ACTIONS: 

  if [[ $MainMenuChoice == "h" ]] ; then

    show_quickemu_WRAP_help

   elif [[ $MainMenuChoice == "del" ]]; then 

    function_delete_Selected_VM  "$VM_InstanceName"  "$VM_Conf_File"

  elif [[ $MainMenuChoice == "hdw" ]] ; then

    AddHW_Record=

    if [[ -e "$QemuArgsFile" ]]; then 

      printf "\033c"

      if [[ -e "$QemuVirtHardwareRecord" ]]; then printf "\n\n  Existing Record: \n\n"; cat "$QemuVirtHardwareRecord"; fi

      printf "\n\n  Current Args / Qemu Virtual Hardware \n\n"
    
      cat "$QemuArgsFile"
      
      if [[ -e "$QemuVirtHardwareRecord" ]]; then printColor "  Copy Current Args onto the end of existing record list?\n\n"

      else printColor "  Create new Virtual Hardware Record using Current Args?\n\n"

      fi

      read -rp "  [enter] to continue  [b] to go back"  AddHW_Record

      if [[ $AddHW_Record != "b" ]]; then 
             
        cat "$QemuArgsFile" >> "$QemuVirtHardwareRecord"

      fi

    else

      printf "\n\n  No Args log found. The virtual machine launch process must be run first. \n\n"

      printf "\n\n  The 'VerboseArgs' option may be used, which will allow checking.  \n\n"

    fi 

  elif [[ $MainMenuChoice == "u" ]] ; then

    if [[ ! $ShowUtilsMenu ]]; then ShowUtilsMenu=1 ; else ShowUtilsMenu= ; fi

  elif [[ $MainMenuChoice == "set" ]] ; then

    qmod_edit_settings

  elif [[ $MainMenuChoice == "gt" ]] ; then

    function_quick_get_wrap

  elif [[ $MainMenuChoice == "m" ]] ; then

    KVM_MSR_selector_LoadHelp=1
    select_msr_config

  elif [[ $MainMenuChoice == "d" ]] ; then 

    printf "\n\n"

    eval quickemu "-vm $VM_Conf_File --vm_boot  $Extra_QE_Params" 

    [[ $InstancePID ]] && printf "\n  SDL: Use guest based display resize. Avoid resizing with the host mouse ...\n\n"

    function_KillPID_Menu
        
  elif  [[ $MainMenuChoice == "s" ]] ; then

    printf "\n\n"

    eval quickemu "-vm $VM_Conf_File --vm_boot --display spice  $Extra_QE_Params"

    #  https://qemu.readthedocs.io/en/latest/system/invocation.html#hxtool-3

    function_KillPID_Menu
      
  elif  [[ $MainMenuChoice == "q" ]] ; then

    printf "\n\n"
    MainMenuChoice=
    exit directly	

  elif  [[ $MainMenuChoice == "sl" ]] ; then

    function_snapshot_list
    printf "\n\n  [enter] to return to menu \n\n "
    read -rp "  >  "  
  
  elif  [[ $MainMenuChoice == "sc" ]] ; then

  function_snapshot_list
  printColor "\n\n  Give [title] or [enter] for date.time  [b] back to menu " 
  SnapTitle=
  printf "\n\n"
  read -rp "  >  "  SnapTitle
  printf "\n\n"	

    [[ ! $SnapTitle ]] && SnapTitle="$(date +%b%d.%R)"
    
    [[ $SnapTitle != "b" ]] && quickemu  -vm "$VM_Conf_File"  --snapshot create  "$SnapTitle"

    printf "\n\n  [enter] to return to menu \n\n "
    read -rp "  >  "  

  elif  [[ $MainMenuChoice == "sd" ]] ; then

    printColor "\n\n Quickemu-Mod Snapshot Deletion:"
    function_snapshot_list

    # Create range-selectable array 
    SnapListString="$(function_snapshot_list | grep '[0-9][0-9]:')"
    mapfile -t SnapListArrRaw <<< "$SnapListString"

    i=0
    printColor "\n\nID   Array  Name \n\n"
    while [[ "${SnapListArrRaw[$i]}" ]]; do
      IFS=' ' read -ra SnapListArrSeparated <<< "${SnapListArrRaw[$i]}"
      printf "%2d    %2d    %s \n"  "${SnapListArrSeparated[0]}"  "$i"  "${SnapListArrSeparated[1]}"
      ((i+=1))
    done

    SnapListArrTotal=$((i-1))

    printColor "\n\nGive ARRAY number 0 to %s of snapshot, or start of snapshot range to delete"  "$SnapListArrTotal"
    printf "\n\n A confirmation prompt will be given before starting ...   [enter] to return to main menu "

    SnapName=
    SnapDeleteStart=
    SnapDeleteEnd=
    SnapDeleteConfirm=
    
    printf "\n\n"
    read -rp " >  "  SnapDeleteStart
    

    if [[ $SnapDeleteStart ]]; then

        printColor "\n\n [enter] for individual snapshot  or  ARRAY [number] for end of range (inclusive) \n\n"
        read -rp " >  "  SnapDeleteEnd

        if [[ $SnapDeleteEnd ]]; then 
          printf "\n Array Range = %s to %s " "$SnapDeleteStart"  "$SnapDeleteEnd"
        else         
          printf "\n Delete = Array entry %s " "$SnapDeleteStart"  
          SnapDeleteEnd="$SnapDeleteStart"
        fi

      printColor "\n\n [enter] to continue  [b] back to main menu \n\n"

      read -rp " >  "  SnapDeleteConfirm


      if [[ $SnapDeleteConfirm == "b" ]]; then

        printf "\n\n Deletion schedule has been CANCELLED"

      else
      
        SnapDeleteRangeCounter=$SnapDeleteStart

        while [[ $SnapDeleteRangeCounter -le $SnapDeleteEnd ]]; do
          IFS=' ' read -ra SnapListArrSeparated <<< "${SnapListArrRaw[$SnapDeleteRangeCounter]}"
          SnapName="${SnapListArrSeparated[1]}"

          if [[ ! $SnapName ]]; then
            printColor "\n\n ERROR with SnapShot Array List \n\n"
            sleep 5
            exit 1
          else
            printColor "\n\n Deleting SnapShot %2d   %2d  %s \n\n"  "${SnapListArrSeparated[0]}"  "$SnapDeleteRangeCounter"  "${SnapListArrSeparated[1]}"
            quickemu  -vm "$VM_Conf_File"  --snapshot delete  "$SnapName"
          fi
          ((SnapDeleteRangeCounter+=1))
        done

      fi

      printf "\n\n [enter] to return to menu \n\n "
      read -rp " >  "  

    fi

    #  TODO  see if tiano core bios can be set to select 'misc device' instead of 'windows boot manager' 
    #        as this can cause problems when rebooting on updates
    
    #  https://github.com/tianocore/tianocore.github.io/wiki/UEFI-application

    #  https://github.com/theopolis/uefi-firmware-parser
          
  elif  [[ $MainMenuChoice == "sa" ]] ; then

    function_snapshot_list
    printColor "\n\n  Give number of snapshot to use  [enter] to return to menu "
    SnapNumber=
    
    printf "\n\n"
    read -rp "  >  "  SnapNumber
    printf "\n\n"	

    if [[ $SnapNumber ]]; then
    
      quickemu -vm "$VM_Conf_File"  --snapshot apply  "$SnapNumber"

      printf "\n\n  May take a moment .... \n\n"
      printColor "\n\n  Snapshot %s has been applied. \n\n"  "$SnapNumber "

    fi
  
  elif [[ $MainMenuChoice == "v" ]] ; then

    if [[ $VerboseArgs ]]; then VerboseArgs=

    else VerboseArgs=1  ; fi

  
  elif [[ $MainMenuChoice == "vm" ]] ; then

    if [[ ! ${VM_Array[0,0]} ]]; then

      function_refresh_and_reload_VM_arrays

    fi

    Select_VM=1
    ByPass_VM_Array_Selector=
    ByPass_VM_Array_Loader=

  elif [[ $MainMenuChoice == "xa" ]] ; then

    MenuXA=
    MenuXA_Correct=

    printColor "\n\n  Give extra qemu arguments to use "
    printf     "\n\n  Format = grouped & with space separated elements "
    printf     "\n\n  eg.  -device  tpm-tis,tpmdev=tpm0 "

    [[ $ExtraSetArgs ]] && printf  "\n\n  Extra Set Args:  %s"  "$ExtraSetArgs"

    if [[ $ExtraArgs ]] && [[ "$ExtraArgs" != "$ExtraSetArgs" ]]; then
    
      printf  "\n\n  Extra Args:  %s"  "$ExtraArgs"

      if [[ $ExtraSetArgs ]]; then printf "\n\n  [r] reset back to Set Args only "

      else printf "\n\n  [r] remove the Extra Args " ; fi

    fi

    printf "\n\n"

    read -rp "  > "  MenuXA

    if [[ $MenuXA != "r" ]]; then

      printf "\n\n  %s %s"  "$ExtraArgs" " $MenuXA"

      printf "\n\n  Is this correct y/n ? \n\n"

      read -rp "  >  "  MenuXA_Correct

    fi

    

    if [[ $MenuXA_Correct == "n" ]]; then printColor "\n\n  Ignoring the entered Qemu Args \n\n" ; sleep 1.5 

    elif [[ $MenuXA == "r" ]]; then printColor "\n\n  Resetting \n\n" ; ExtraArgs="$ExtraSetArgs" ; sleep 1 
    
    else  ExtraArgs="$ExtraArgs $MenuXA" ; fi

    printf "\033c\n\n"


  fi

done


# vim:tabstop=2:shiftwidth=2:expandtab

## 